<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <style>
        html, body {
            zoom: 1 !important;
            height: 100%;
            overflow: hidden; /* disable page scrolling */
            padding-top: env(safe-area-inset-top, 10px); /* prevent notch / top cropping */
        }
    </style>
    <title>HeyCash!</title>
    <link href="https://fonts.googleapis.com/css2?family=Mona+Sans:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* --- CSS STYLES --- */
        :root {
            --bg-color: #00c853;
            --mobile-banner-height: 80px; /* central source of truth for banner + safe spacing */
            --grid-bg: rgba(255,255,255,0.06);
            --cell-bg: rgba(255,255,255,0.06);
            --text-color: #072014;
            --accent-color: #00e676;
            --gap: 1vmin; /* Responsive gap */
        }

        body {
            position: relative;
            color: var(--text-color);
            font-family: 'Mona Sans', 'Helvetica', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            position: relative;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body::before {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: url('images/HC-bg.png') no-repeat center center fixed;
            background-size: cover;
            z-index: -1;
            pointer-events: none;
            filter: brightness(1.2), saturate(0.9); ;
        }

        /* Responsive Container */
    #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    /* FIX: Center vertically to remove the big gap at the bottom */
    justify-content: center; 
    width: 80%;
    height: auto;
    max-height: calc(100vh - var(--mobile-banner-height) - env(safe-area-inset-top, 0px));
    margin: 0 auto;
        /* FIX: Use flexible vertical padding (vh) and respect top safe-area */
        /* Reduced top padding to tighten space between logo and top */
        padding: calc(0.8vh + env(safe-area-inset-top, 6px)) 10px; 
        
        /* expose grid sizing variables so dock items can match grid cell size */
        --grid-size: clamp(300px, 45vmin, 380px);
        --cell-size: calc((var(--grid-size) - (9 * var(--gap))) / 8);
        
        box-sizing: border-box;
        gap: clamp(0.3rem, 0.6vmin, 0.6rem);
        position: relative;
        z-index: 1;
        overflow: hidden; /* disable container scrolling */
    }

        @media (orientation: landscape) {
            /* Landscape: arrange content horizontally for wider viewports */
            #game-container {
                max-width: 100%;
                width: 100%;
                flex-direction: row; /* place logo and play-area side-by-side */
                align-items: flex-start;
                justify-content: center;
                gap: clamp(8px, 2vmin, 18px);
                padding: calc(1vh + env(safe-area-inset-top, 6px)) 12px;
            }

            /* Let play-area expand while keeping the grid constrained by --grid-size */
            .play-area {
                flex: 1 1 auto;
                max-width: calc(100% - 320px);
                padding: 0 clamp(12px, 4vmin, 48px);
                align-items: flex-start;
                gap: 8px;
            }

            /* Smaller left-aligned logo in landscape */
            .logo {
                width: clamp(80px, 12vmin, 160px);
                height: auto;
                margin-right: 12px;
                margin-bottom: 0;
                align-self: flex-start;
            }

            /* Stack HUD and dock vertically to the right of the play-area */
            .hud-row { order: 2; margin-bottom: 6px; }
            .dock { order: 3; margin-top: 6px; align-self: flex-end; }

            /* Ensure grid scales properly in landscape by capping grid-size relative to viewport height */
            :root { --grid-size: clamp(260px, 50vmin, 420px); }
        }
.dock {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
    overflow: visible !important; /* Show shadows/glows outside the box */
    position: relative;
    z-index: 900;
}

/* Hide scrollbar for Chrome, Safari and Opera */
.dock::-webkit-scrollbar {
    display: none;
}
        /* Logo styling */
        .logo {
            width: min(20vmin, 100px);
            max-width: 50%;
            height: auto;
            object-fit: contain;
            animation: bounce-in 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            margin-bottom: 0;
        }

        /* Larger logo on start and game-over screens */
        #start-screen .logo,
        #game-over .logo {
            width: clamp(220px, 45vmin, 550px);
            max-width: 92%;
            height: auto;
            margin-bottom: clamp(12px, 2vmin, 24px);
        }

        @keyframes bounce-in {
            0% { opacity: 0; transform: scale(0.3) translateY(-30px); }
            50% { opacity: 1; }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        /* Runtime short-screen classes applied by JS (for devices like iPhone SE) */
        :root.short-screen .logo { width: clamp(44px, 11vmin, 76px); }
        :root.very-short-screen .logo { width: clamp(36px, 10vmin, 64px); }
        /* Slightly lower padding for short/very-short screens to keep logo closer to top */
        :root.short-screen #game-container { padding-top: calc(2vh + env(safe-area-inset-top, 0px)); }
        :root.very-short-screen #game-container { padding-top: calc(1vh + env(safe-area-inset-top, 0px)); }
        :root.short-screen { --grid-size: clamp(260px, 38vmin, 320px); }
        :root.very-short-screen { --grid-size: clamp(220px, 34vmin, 280px); }
        :root.very-short-screen #tutorial-pointer { width: clamp(36px, 14vmin, 96px) !important; }

        /* Install CTA styling */
        .install-cta {
            width: 160px; /* Increase button size */
            height: auto; /* Maintain aspect ratio */
            font-size: 14px; /* Reduce font size */
            padding: 10px; /* Add padding for better spacing */
            box-shadow: 0 12px 28px rgba(0,0,0,0.45); /* Enhanced shadow for depth */
            transition: transform 0.2s ease;
            margin-top: clamp(0.3rem, 0.5vmin, 0.8rem);
            animation: pulse-install 3s ease-in-out infinite;
            /* Place on top of the grid / centered */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: -26px;
            z-index: 20;
        }

        /* Hide inline install-cta on small screens; mobile banner provides install CTA */
        @media (max-width: 480px) {
            .install-cta { display: none; }
            #game-container {
                width: 100%;
                height: auto;
                padding: 2vh 4vmin; /* Increased horizontal padding for small screens */
            }
            /* Keep badges side-by-side in a single horizontal row with horizontal scrolling if needed */
            .hud-row { display: flex; flex-direction: row; justify-content: space-around; align-items: center; gap: 1rem; overflow-x: auto; white-space: nowrap; padding: 0 4vmin; }
            /* Let grid and play area scale to fit the width available */
            .grid-container { width: 100%; height: auto; }
        }
        
        .install-cta:hover {
            transform: scale(1.05); /* Slight hover effect */
        }

        @keyframes pulse-install {
            0% { transform: scale(1); filter: drop-shadow(0 0 0 rgba(0, 230, 118, 0)); }
            50% { transform: scale(1.01); filter: drop-shadow(0 0 12px rgba(0, 230, 118, 0.4)); }
            100% { transform: scale(1); filter: drop-shadow(0 0 0 rgba(0, 230, 118, 0)); }
        }

        /* Badge using the provided image (images/unnamed.jpg) */
        .badge {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0;
            background: none;
            border: none;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
            width: clamp(110px, 15vmin, 140px);
            height: clamp(36px, 6vmin, 44px);
            font-size: clamp(10px, 1.8vmin, 12px);
            font-weight: 700;
            font-family: 'Mona Sans', sans-serif;
            position: relative;
            background-image: url('images/bar.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 12px;
            /* NEW: give a subtle elevation and glassy feel on the bottom HUD */
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
            background-color: rgba(255,255,255,0.05);
        }

        /* Enhanced bottom HUD aesthetics: glassy pills with soft shadows for timer/score */
        .hud-left .badge, .hud-right .badge {
            background: rgba(0, 0, 0, 0.32);
            border-radius: 99px;
            padding: 8px 14px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(3px);
        }

        /* HUD container (stacked vertically) */
        .hud-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            width: auto;
            box-shadow: none;
            backdrop-filter: none;
            animation: fade-slide-in 0.8s ease-out 0.2s backwards;
            position: static;
            top: auto;
            left: auto;
            right: auto;
            z-index: 100;
            box-sizing: border-box;
        }

        /* Hide left banner on small screens and restore HUD padding */
        @media (max-width: 600px) {
            .hey-banner { display: none; }
            .hud-container { padding-left: clamp(1rem, 3vmin, 2rem); }
            /* Keep main dock visible on mobile so pieces spawn in the intended area */
            .mobile-dock-floating { display: flex; }
            /* leave just enough space for the mobile banner + safe area */
            #game-container { padding-bottom: calc(var(--mobile-banner-height) + env(safe-area-inset-bottom, 0px) + 8px); }
        }

        @keyframes fade-slide-in {
            0% { opacity: 0; transform: translateY(-20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .stat-box {
            background: transparent;
            padding: 0;
            border: none;
            text-align: center;
            color: #ffffff;
            font-family: 'Mona Sans', sans-serif;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            font-size: clamp(15px, 1.6vmin, 19px);
            letter-spacing: 0.5px;
            position: relative;
            z-index: 1;
            animation: pulse-badge 2s ease-in-out infinite;
        }

        @keyframes pulse-badge {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Enhanced Timer Display */
        #timer {
            font-size: 24px; /* Fixed size */
            font-family: 'Mona Sans', sans-serif;
            color: #ffeb3b;
            text-shadow: 0 4px 8px rgba(255, 235, 59, 0.8);
            animation: timer-glow 1.5s ease-in-out infinite;
        }

        @keyframes timer-glow {
            0%, 100% { transform: scale(1); text-shadow: 0 4px 8px rgba(59, 255, 98, 0.292); }
            50% { transform: scale(1.1); text-shadow: 0 6px 12px rgba(72, 255, 59, 0.459); }
        }

        /* THE GRID */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(8, var(--cell-size));
            grid-template-rows: repeat(8, var(--cell-size));
            gap: calc(var(--gap) * 1.18);
            background: rgba(0,0,0,0.18); /* much more visible background */
            padding: calc(var(--gap) * 1.5);
            border-radius: 40px;
            box-shadow:
                0 16px 60px 0 rgba(0,64,47,0.22),
                0 1px 35px 3px #43ff9525 inset;
            outline: none;
            width: var(--grid-size);
            height: var(--grid-size);
            aspect-ratio: 1 / 1;
            position: relative;
            animation: slide-up 0.8s ease-out 0.3s backwards;
            margin: clamp(0.3rem, 0.5vmin, 0.8rem) auto;
        }

        /* spacing for HUD above grid */
        .hud-row { margin-bottom: 8px; }

        /* Play area wrapper to keep grid, CTA and dock centered as a group */
        .play-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* allow play-area to take full width of game-container, with horizontal padding */
            width: 100%;
            max-width: 900px; /* Increased max-width for more space */
            padding: 0 clamp(20px, 6vmin, 60px); /* Increased horizontal padding */
            box-sizing: border-box; /* Include padding in element's total width and height */
            margin: 0 auto; /* Center the play area */
            gap: clamp(0.4rem, 1vmin, 0.8rem);
            position: relative; /* allow absolute HUD placement beside the play area */
        }

        /* HUD elements placed to the sides of the play-area (now stacked vertically) */
        .hud-side {
            position: static;
            transform: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        /* place to the left of the play-area */
        .hud-left {
            right: calc(100% + clamp(12px, 1.6vmin, 20px));
        }

        /* place to the right of the play-area */
        .hud-right {
            left: calc(100% + clamp(12px, 1.6vmin, 20px));
        }

        /* On small screens, push HUD to top and make them flow horizontally */
        @media (max-width: 900px) {
            .hud-side {
                position: static;
                transform: none;
                flex-direction: row;
                gap: clamp(12px, 2vmin, 18px);
                justify-content: center;
                width: 100%;
            }
            .hud-left, .hud-right { left: auto; right: auto; }
        }

        @keyframes slide-up {
            0% { opacity: 0; transform: translateY(40px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .cell {
            width: 100%;
            height: 100%;
            background-color: transparent;
            border-radius: 50%;
            background-size: cover;
            box-shadow: 0 0 0px 0 #0000, 0 0 0px 0 #0000;
            transition: transform 0.15s ease, box-shadow 0.2s;
            position: relative;
        }
        .cell:after {
            content: "";
            position: absolute;
            top: 6.5%; left: 6.5%; right: 6.5%; bottom: 6.5%;
            border-radius: 50%;
            /* Glossy, light well with subtle sheen (not fully solid) */
            background:
                linear-gradient(150deg, rgba(255,255,255,0.42) 0%, rgba(255,255,255,0.18) 32%, rgba(255,255,255,0) 33%),
                radial-gradient(65% 65% at 50% 45%, rgba(255,255,255,0.94) 0%, rgba(255,255,255,0.88) 55%, rgba(255,255,255,0.22) 100%);
            box-shadow:
                0 1px 0 rgba(255,255,255,0.55) inset,
                0 0 0.55vmin 0.35vmin rgba(255,255,255,0.28) inset,
                0 2px 8px rgba(0,0,0,0.12);
            border: 1px solid rgba(255,255,255,0.32);
            z-index: 0;
            pointer-events: none;
        }
        .cell.has-coin:after {
            background: none !important;
            box-shadow: none !important;
            border: none !important;
        }

        .cell.highlight {
            outline: 3px solid #afffc8;
            box-shadow: 0 0 22px 6px #37e49176;
            background-color: rgba(255,255,255,0.05);
        }

        .cell:hover {
            transform: scale(1.06);
            filter: brightness(1.12);
            box-shadow: 0 0 32px 13px #36ffd280;
        }

        .cell.clearing {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { filter: brightness(2); background-color: #fff; transform: scale(1.1); }
            100% { transform: scale(0); opacity: 0; }
        }

        /* The DOCK: visible holder for the 3 puzzle pieces */
        .dock {
            display: flex;
            flex-direction: row; /* force row as the default */
            align-items: center;
            justify-content: space-between; /* spread the 3 pieces */
            gap: clamp(14px, 3.2vmin, 28px);
            height: auto;
            width: var(--grid-size); /* match grid width */
            max-width: var(--grid-size);
            z-index: 3700; /* sit above the bottom banner */
            position: relative;
            flex-wrap: nowrap;
            overflow-x: auto; /* enable horizontal scroll on narrow screens */
            -webkit-overflow-scrolling: touch;
            margin-top: 8px;
            padding: 12px 12px;
            box-sizing: border-box;
            animation: fade-slide-in 0.8s ease-out 0.2s backwards;
            /* rounded frosted panel behind the pieces */
            background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
            border-radius: 18px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.28);
            backdrop-filter: blur(10px) saturate(1.05);
            border: 1px solid rgba(255,255,255,0.04);
        }

        .block-shape {
            display: grid;
            gap: 2px;
            cursor: pointer;
            position: relative; 
            touch-action: none;
            animation: block-bounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes block-bounce {
            0% { opacity: 0; transform: scale(0.5) translateY(-20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        /* Dock / block picker sizes: match the computed grid cell size */
        .dock .block-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border-radius: 50%;
            pointer-events: none;
            background-size: cover;
            box-shadow: 0 6px 20px 5px rgba(0,255,128,0.09), 0 0 10px 0 rgba(0,0,0,0.14) inset;
            margin: 0;
            background-color: transparent;
        }

        /* Slight inset behind each block to make dock read as a container */
        .dock .block-shape { padding: 6px; border-radius: 12px; background: transparent; }

        /* fallback for other contexts */
        .block-cell {
            width: clamp(18px, 3.2vmin, 28px);
            height: clamp(18px, 3.2vmin, 28px);
            border-radius: 50%;
            pointer-events: none;
            background-size: cover;
            background-color: transparent;
            box-shadow: 0 4px 15px rgba(0,255,128,0.10), 0 0 6px 0 rgba(0,0,0,0.11) inset;
        }

        /* Dragging State */
        .dragging {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            opacity: 0.85;
            filter: drop-shadow(0 8px 16px rgba(0,0,0,0.5));
        }

        /* FIX: Ensure cells inside the dragging container fill the space (since they lose dock context) */
        .dragging .block-cell {
            width: 100% !important;
            height: 100% !important;
        }

        /* OVERLAYS (Start & End) */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* slightly more transparent so decorative elements show through */
            background: rgba(20, 30, 25, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 5vmin;
            box-sizing: border-box;
            animation: fade-in 0.6s ease-out;
            backdrop-filter: blur(30px);
        }

        @keyframes fade-in {
            0% { opacity: 0; backdrop-filter: blur(0px); }
            100% { opacity: 1; backdrop-filter: blur(3px); }
        }

        .overlay h1 {
            font-size: clamp(24px, 8vmin, 48px);
            margin: 0 0 2vmin 0;
            text-align: center;
            color: #ffffff;
            text-shadow: 0 4px 8px rgba(0,0,0,0.8);
            animation: text-pop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes text-pop {
            0% { opacity: 0; transform: scale(0.8) translateY(-20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }

        .overlay h2 {
            font-size: clamp(18px, 6vmin, 36px);
            margin: 0 0 3vmin 0;
            text-align: center;
            color: #ffffff;
            text-shadow: 0 4px 8px rgba(0,0,0,0.8);
            animation: text-pop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) 0.1s backwards;
        }

        .overlay p {
            font-size: clamp(14px, 4vmin, 20px);
            margin: 0 0 3vmin 0;
            text-align: center;
            color: #ffffff;
            text-shadow: 0 3px 6px rgba(0,0,0,0.8);
        }

        /* Start-screen points list with highlighted final line */
        .start-points {
            list-style: none;
            padding: 0;
            margin: 0 0 3vmin 0;
            display: grid;
            gap: clamp(6px, 1.8vmin, 12px);
            justify-items: center;
        }
        .start-points li {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ffffff;
            font-weight: 800;
            font-size: clamp(16px, 5vmin, 28px);
            text-shadow: 0 4px 8px rgba(0,0,0,0.8);
        }
        .start-points .dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: #00e676;
            box-shadow: 0 0 10px rgba(0,230,118,0.6);
        }
        .start-points li.highlight {
            color: #0b2117;
            background: linear-gradient(90deg, #00D166, #00b85a);
            padding: 8px 18px;
            border-radius: 999px;
            box-shadow: 0 12px 26px rgba(0,230,118,0.55), inset 0 1px 0 rgba(255,255,255,0.35);
            animation: reward-pulse 1.25s ease-in-out infinite;
        }

        .cta-btn {
            padding: min(4vmin, 15px) min(8vmin, 40px);
            font-size: clamp(16px, 5vmin, 24px);
            background: var(--accent-color);
            border: none;
            color: #1a221d;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 3vmin;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            animation: pulse 1.5s infinite, pop-in 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) 0.5s backwards;
            font-family: 'Mona Sans', sans-serif;
            transition: transform 0.2s ease;
        }

        .block-shape.returning {
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 10000; /* Ensure it stays on top while returning */
        }

        .cta-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 8px 25px rgba(0, 230, 118, 0.5);
        }

        @keyframes pulse {
            0% { box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
            50% { box-shadow: 0 8px 25px rgba(0, 230, 118, 0.5); }
            100% { box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
        }

        @keyframes pop-in {
            0% { opacity: 0; transform: scale(0); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* --- HEYCASH LEFT SIDEBAR BANNER --- */
        .hey-banner {
            position: fixed;
            left: clamp(8px, 1.2vmin, 16px);
            top: 50%;
            transform: translateY(-50%);
            width: clamp(140px, 20vmin, 220px);
            background: rgba(255,255,255,0.98);
            border-radius: 18px;
            display: none; /* Hide initially (on start screen) */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: clamp(8px, 1.2vmin, 12px);
            padding: clamp(10px, 1.2vmin, 14px);
            box-sizing: border-box;
            box-shadow: 0 14px 36px rgba(0,0,0,0.18);
            z-index: 3000;
            cursor: pointer;
            transition: transform 0.22s ease, box-shadow 0.22s ease;
            overflow: hidden; /* keep internal graphics from spilling out */
        }

        .hey-banner:hover {
            transform: translateY(-50%) translateX(-4px);
            box-shadow: 0 18px 40px rgba(0,0,0,0.22);
        }

        .hey-logo-area {
            display: flex;
            align-items: center;
            gap: 10px;
            animation: fade-slide-in 0.8s ease-out 0.2s backwards;
        }

        .hey-icon {
            width: clamp(48px, 8vmin, 64px);
            height: clamp(48px, 8vmin, 64px);
            background: transparent;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            animation: rotate-bounce 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* NEW HUD DESIGN - responsive and will not overflow viewport */
        .hud-row {
            display: flex;
            justify-content: space-around; /* Evenly distribute items with space around them */
            align-items: center;
            gap: clamp(12px, 3vmin, 24px); /* Slightly reduced responsive gap to save vertical space */
            width: 100%; /* Take full width of parent (.play-area) */
            max-width: 100%;
            padding: 0; /* Padding is now on .play-area */
            box-sizing: border-box;
            flex-wrap: nowrap; /* Prevent items from wrapping (stacking) */
            margin: 0 auto; /* Center the entire HUD row */
            overflow: visible;
        }

        .hud-item {
            position: relative;
            /* slightly darker base */
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.489), rgba(0, 0, 0, 0.331));
            border: 1px solid rgba(0,0,0,0.18);
            border-radius: 14px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            /* allow cards to grow/shrink based on available space */
            flex: 1 1 140px; /* Base width reduced to save space */
            min-width: 120px; /* Slightly smaller minimum */
            max-width: 220px; /* Slightly smaller maximum */
            /* softened shadow to reduce visual weight */
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.087), inset 0 1px 0 rgba(255,255,255,0.01);
            backdrop-filter: blur(6px) saturate(1.05);
            transition: transform 200ms cubic-bezier(.2,.9,.3,1), box-shadow 200ms ease;
            overflow: hidden;
        }

        /* Ensure label/value text truncates instead of pushing layout */
        .hud-text { display: flex; flex-direction: column; align-items: flex-start; line-height: 1.02; min-width: 0; overflow: hidden; }
        .hud-value { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 800; }
            

        .card-stack {
            position: relative;
            width: clamp(64px, 12vmin, 88px);
            height: clamp(44px, 8vmin, 56px);
            margin-top: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        
        .c-card {
            width: clamp(48px, 8vmin, 64px);
            height: clamp(34px, 6vmin, 44px);
            border-radius: 6px;
            position: absolute;
            box-shadow: 0 4px 12px rgba(0,0,0,0.18);
            border-top: 1px solid rgba(255,255,255,0.4);
        }

        .c-card.one {
            background: #232f3e; 
            top: 6px; left: 6px;
            transform: rotate(-12deg) scale(0.98);
            z-index: 1;
        }
        
        .c-card.two {
            background: #0070ba;
            top: 2px; left: calc(50% - 22px);
            transform: rotate(0deg) scale(0.98);
            z-index: 2;
        }

        .c-card.three {
            background: linear-gradient(45deg, #00D166, #00b85a);
            top: 6px; right: 6px;
            transform: rotate(12deg) scale(0.98);
            z-index: 3;
        }

        .hey-btn {
            background: #000;
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 13px;
            cursor: pointer;
            animation: pulse-banner 1.5s infinite;
            width: 100%;
            box-sizing: border-box;
        }

        @keyframes pulse-banner {
            0% { box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 0, 0, 0); }
        }

        /* --- MOBILE BANNER (white bottom on small screens) --- */
        .mobile-banner {
            display: none; /* shown via media query */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--mobile-banner-height); /* slightly smaller for discreteness */
            background: rgba(255, 255, 255, 0.654); /* subtle glass */
            backdrop-filter: blur(8px) saturate(1.05);
            -webkit-backdrop-filter: blur(8px) saturate(1.05);
            border-top-left-radius: 26px;
            border-top-right-radius: 26px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 14px;
            box-sizing: border-box;
            z-index: 3500;
            box-shadow: 0 -6px 18px rgba(0,0,0,0.06);
            border-top: 1px solid rgba(255,255,255,0.06);
            color: rgba(7,32,20,0.95);
            transition: opacity 360ms ease, transform 360ms ease;
        }

        .mobile-banner .mobile-left { display:flex; align-items:center; gap:10px; }
        .mobile-side-logo {
            width: 44px;
            height: 44px;
            object-fit: contain;
            border-radius: 8px;
            margin-right: 6px;
            display: inline-block;
        }
        .mobile-logo { width:44px; height:44px; background: url('images/Logo.png') center/contain no-repeat; background-color: transparent; border-radius:8px; }
        .mobile-text { color: #072014; font-weight:700; font-size:14px; line-height:1; }
        .mobile-sub { font-weight:600; font-size:12px; color: #556b6a; }

        .mobile-dock { display:flex; gap:10px; align-items:center; overflow-x:auto; -webkit-overflow-scrolling:touch; padding-bottom:6px; max-width: 55%; }
        .mobile-dock .block-cell { width: 36px; height: 36px; border-radius:6px; box-shadow: 0 6px 14px rgba(0,0,0,0.28); }

        /* Floating dock that appears above the mobile banner */
        .mobile-dock-floating { display:none; }
        @media (max-width: 600px) {
            .mobile-dock-floating { display:flex; position: fixed; left: 50%; transform: translateX(-50%); bottom: 126px; gap: 16px; z-index: 3600; padding: 8px 12px; background: rgba(0,0,0,0.06); border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,0.25); }
            .mobile-dock-floating .block-cell { width: 44px; height:44px; border-radius:8px; }
        }

        .mobile-coin { width:34px; height:34px; border-radius:50%; background: radial-gradient(circle at 35% 30%, #fff5b1, #ffd24d 40%, #00e676 70%); display:flex; align-items:center; justify-content:center; color:#06401f; font-weight:900; box-shadow: 0 6px 14px rgba(0,0,0,0.25); font-size:18px; }

        /* Mobile install image (banner) */
        .mobile-install-img { width: 120px; height: 44px; object-fit: contain; display:inline-block; cursor: pointer; box-shadow: 0 6px 12px rgba(0,0,0,0.08); border-radius: 10px; background: transparent; }

        /* Gift card graphics for the banner */
        .gift-cards-icon {
            position: relative;
            width: 96px;
            height: 56px;
            margin: 0 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-graphic {
            position: absolute;
            width: 52px;
            height: 36px;
            border-radius: 6px;
            box-shadow: 1px 1px 6px rgba(0,0,0,0.12);
            border-top: 2px solid rgba(0,0,0,0.06);
            background-size: cover;
            background-position: center;
        }

        /* Card 1: orange base with logo overlay */
        .card-1 {
            background-color: #ff9900;
            top: 0;
            left: 0;
            z-index: 1;
            transform: rotate(-10deg);
        }

        /* Card 2: prominent central card (logo) */
        .card-2 {

            background-color: #0056b3;
            top: 6px;
            left: 14px;
            z-index: 2;
            transform: rotate(0deg);
        }

        /* Card 3: green base with logo overlay */
        .card-3 {
            background-color: #2ecc71;
            top: 12px;
            left: 28px;
            z-index: 3;
            transform: rotate(10deg);
        }

        /* Mobile-banner specific gift-card overrides (smaller, compact stack) */
        .mobile-banner .gift-card {
            position: absolute;
            width: 52px;
            height: 36px;
            border-radius: 8px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.18);
            border: 1px solid rgba(0,0,0,0.06);
            left: 0; top: 0;
            background-size: cover;
        }
        .mobile-banner .gift-card.g1 { left: 6px; top: 0; transform: rotate(-8deg); background: linear-gradient(135deg,#00c853,#00e676); z-index:3; }
        .mobile-banner .gift-card.g2 { left: 20px; top: 6px; transform: rotate(0deg); background: linear-gradient(135deg,#0056b3,#1e88e5); z-index:2; }
        .mobile-banner .gift-card.g3 { left: 34px; top: 12px; transform: rotate(8deg); background: linear-gradient(135deg,#ff9900,#ffb74d); z-index:1; }
        .mobile-banner .gift-card .card-logo { width: 22px; height:22px; right:6px; top:6px; }

/* Desktop: show banner as a vertical card on the right side AND squish layout */
@media (min-width: 600px) {
    /* 1. SQUISH THE CONTAINER */
    #game-container { 
        /* Force grid to be exactly half the screen height */
        --grid-size: 50vh !important; 
        
        /* Remove bottom padding that was pushing things up */
        padding-bottom: 2vh !important;
        padding-top: 2vh !important;
        
        /* Center everything vertically */
        justify-content: center;
        gap: 1vh; /* Very tight gap between elements */
    }
    
    /* 2. SQUISH THE LOGO */
    .logo {
        height: 10vh !important; /* Limit logo to 10% of screen height */
        width: auto;
        max-height: 80px; /* Cap it so it doesn't get huge */
        margin-bottom: 0 !important;
    }

    /* 3. SQUISH THE DOCK */
    .dock {
        margin-top: 0 !important;
        padding-top: 0 !important;
        /* Scale down the pieces to 85% size to save vertical space */
        transform: scale(0.85);
        transform-origin: top center;
    }

    /* 4. SIDE BANNER POSITIONING (Your original code) */
    .mobile-banner {
        display: flex; 
        position: fixed;
        bottom: auto; left: auto;
        right: clamp(12px, 2vmin, 24px);
        top: 50%; 
        transform: translateY(-50%);
        width: clamp(260px, 26vw, 360px);
        height: auto;
        background: rgb(255, 255, 255);
        border-radius: 16px;
        box-shadow: 0 14px 36px rgba(0,0,0,0.18);
        z-index: 3500;
        padding: 16px;
        gap: 12px;
        flex-direction: column;
        align-items: stretch;
    }
    
    .mobile-banner .mobile-left { align-items: center; gap: 10px; }
    .mobile-banner .gift-cards-icon { margin: 6px auto; }
    /* Ensure the install image fits inside the card */
    .mobile-banner .mobile-install-img { width: 86%; max-width: 300px; height: auto; align-self: center; }
    
    /* Hide the small dock inside the banner on desktop */
    .mobile-banner .mobile-dock { display: none; }
    
    /* Hide the floating button since we have the full banner */
    .desktop-install-cta { display: none !important; }
}
  .reward-card {
    background: #4a5a63; /* Dark slate grey */
    border-radius: 24px;
    padding: 30px 20px 40px 20px;
    text-align: center;
    width: clamp(280px, 80vw, 340px);
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    position: relative;
    border: 1px solid rgba(255,255,255,0.1);
    animation: pop-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes card-pop {
    0% { opacity: 0; transform: scale(0.6) rotateY(90deg); }
    100% { opacity: 1; transform: scale(1) rotateY(0deg); }
}

/* White PayPal Pill */
.reward-display {
    background: #ffffff;
    border-radius: 16px;
    padding: 22px 22px; /* extra vertical padding for more height */
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    min-height: clamp(96px, 14vmin, 130px); /* make the PayPal pill noticeably taller */
    box-sizing: border-box;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    position: relative;
    z-index: 10; /* Important: Sits ABOVE the fake cards */
}

/* Container for the fake cards */
.more-cards {
    position: relative;
    width: 100%;
    height: 0; /* Ensures it doesn't push the button down */
    display: flex;
    justify-content: center;
    margin-top: -26px; /* Tuck the stack further UNDER the white pill so only bottoms show */
    z-index: 1; /* Sits BEHIND the white box */
}

/* Base style for all fake cards */
.card-fake {
    position: absolute;
    left: 50%; /* Force horizontal center */
    width: 92%; 
    height: 45px;
    border-radius: 0 0 16px 16px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

/* --- STACKING LOGIC (Removed conflicting nth-child rules) --- */

/* Top Card (Green) - Closest to white box */
.card-fake.green {
    background: #00c853;
    z-index: 3;
    /* Center X, Move Down Y, Scale */
    transform: translateX(-50%) translateY(10px) scale(0.95);
}

/* Middle Card (Black) */
.card-fake.black {
    background: #1a1a1a;
    z-index: 2;
    transform: translateX(-50%) translateY(22px) scale(0.90);
}

/* Bottom Card (Gray) */
.card-fake.gray {
    background: #b0bec5;
    z-index: 1;
    transform: translateX(-50%) translateY(36px) scale(0.85);
}

/* --- INNER CONTENT STYLES --- */
.reward-display-left {
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 0;
}

.reward-display-logo {
    width: 64px; /* larger logo area to fit the taller card */
    height: 64px;
    background: #fff;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #eee;
}
.reward-display-logo img { width: 80%; height: auto; }

.reward-display-label {
    font-size: 22px;
    color: #666;
    font-weight: 600;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.reward-display-amount {
    font-size: clamp(26px, 7vmin, 48px);
    font-weight: 900;
    color: #1a1a1a;
    animation: pulse-amount 2s ease-in-out infinite;
    margin-left: 12px;
    flex-shrink: 0;
}

        /* rotating decorative sun shown for game-over */
        #game-over .sun-rot {
            position: absolute;
            left: 50%;
            top: 48%;
            transform: translate(-50%, -50%);
            width: clamp(260px, 40vmin, 600px);
            height: clamp(260px, 40vmin, 600px);
            background: url('images/sun.png') no-repeat center/contain;
            opacity: 0.98;
            pointer-events: none;
            z-index: 0; /* behind overlay content but above the overlay background */
            animation: spin 12s linear infinite;
            filter: drop-shadow(0 12px 28px rgba(0,0,0,0.28));
        }

        @keyframes spin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to   { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* ensure overlay children appear above the sun */
        #game-over > * { position: relative; z-index: 1; }

        @keyframes pulse-amount {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        .reward-text {
            color: #d0d0d0;
            font-size: 22px;
            margin-bottom: 10px;
        }

        .reward-btn {
            position: relative;
            background: transparent;
            color: #0b2117;
            border: none;
            padding: 0;
            cursor: pointer;
            margin-top: 24px;
            display: inline-block;
            margin-left: auto;
            margin-right: auto;
            line-height: 0; /* remove inline-img gap */
            box-shadow: none;
            animation: none;
            transform-origin: center;
            width: clamp(220px, 56vw, 320px);
            height: auto;
        }
        .reward-btn .reward-img {
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            filter: drop-shadow(0 12px 28px rgba(0,0,0,0.35));
            position: relative;
            z-index: 1;
        }
        .reward-btn-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00000094;
            font-family: 'Mona Sans', 'Helvetica', sans-serif;
            font-weight: 900;
            font-size: clamp(20px, 4vw, 22px);
            letter-spacing: 1px;
            text-transform: uppercase;
            pointer-events: none;
            width: 90%;
            text-align: center;
            z-index: 2;
            white-space: nowrap;
            text-shadow: 0 1px 8px #fffde644, 0 2px 12px #07892433;
        }
        

        /* Moving Gradient Background */
        @keyframes gradient-move {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* Heartbeat Scale + Shadow Pulse */
        @keyframes heartbeat {
            0% { transform: scale(1); box-shadow: 0 10px 40px rgba(0, 230, 118, 0.6), 0 0 0 6px rgba(255, 255, 255, 0.2); }
            15% { transform: scale(1.05); box-shadow: 0 15px 50px rgba(0, 230, 118, 0.8), 0 0 0 10px rgba(255, 255, 255, 0.1); }
            30% { transform: scale(1); box-shadow: 0 10px 40px rgba(0, 230, 118, 0.6), 0 0 0 6px rgba(255, 255, 255, 0.2); }
            45% { transform: scale(1.05); box-shadow: 0 15px 50px rgba(0, 230, 118, 0.8), 0 0 0 10px rgba(255, 255, 255, 0.1); }
            100% { transform: scale(1); box-shadow: 0 10px 40px rgba(0, 230, 118, 0.6), 0 0 0 6px rgba(255, 255, 255, 0.2); }
        }

        /* Shine effect sweep */
        .reward-btn::after { content: none; }

        @keyframes shine-sweep {
            0%, 60% { left: -100%; opacity: 0; }
            70% { opacity: 1; }
            100% { left: 200%; opacity: 0; }
        }
        
        #game-over { display: none; }

        /* FORCE mobile overrides placed last to prevent earlier rules from winning
           Ensures desktop dock is hidden and floating mobile dock is visible */
        @media (max-width: 600px) {
            /* Keep main dock visible on mobile */
            .mobile-dock-floating { display: flex !important; }
            /* position floating dock just above the 120px banner + safe area */
                .mobile-dock-floating { bottom: calc(var(--mobile-banner-height) + env(safe-area-inset-bottom, 0px) + 12px) !important; }
                #game-container { padding-bottom: calc(var(--mobile-banner-height) + env(safe-area-inset-bottom, 0px) + 8px) !important; }
        }

        /* Desktop layout fixes: keep column compact, enlarge grid, and make dock horizontal */
        #game-container { width: 100%; max-width: 900px; margin-left: auto; margin-right: auto; }
        @media (min-width: 768px) {
            #game-container { --grid-size: clamp(420px, 52vmin, 560px); }
            .dock { flex-direction: row; gap: clamp(20px, 4vmin, 36px); max-width: var(--grid-size); width: var(--grid-size); padding: 0; justify-content: space-between; }
            .hud-row { gap: clamp(1rem, 3vmin, 2rem); }
        }

        /* Ensure HUD stays side-by-side on wider viewports */
        @media (min-width: 700px) {
            .hud-row {
                justify-content: space-around; /* Evenly distribute items with space around them */
                gap: clamp(24px, 4vmin, 48px); /* Increased responsive gap */
            }
            .hud-item {
                flex: 1 1 200px; /* Allow items to grow/shrink, with a larger base */
                min-width: 180px; /* Increased minimum width */
                max-width: 320px; /* Increased maximum width */
            }
        }

        /* Stronger desktop dock rules to prevent vertical stacking */
        @media (min-width: 600px) {
            .dock {
                flex-direction: row !important;
                flex-wrap: nowrap !important;
                overflow-x: auto;
                justify-content: space-between;
                align-items: flex-start;
                max-width: var(--grid-size);
                width: var(--grid-size);
            }
            .dock .block-shape {
                display: inline-grid;
                flex: 0 0 auto;
                width: auto; /* allow natural width based on internal cells */
                height: auto;
                transform: none !important;
            }
            .dock .block-cell {
                /* slightly reduce dock preview cell size so multiple pieces fit comfortably */
                width: calc(var(--cell-size) * 0.80);
                height: calc(var(--cell-size) * 0.80);
            }
        }

        /* Extra shrink for narrow viewports to keep the dock compact without shifting layout */
        @media (max-width: 700px) {
            .dock .block-cell {
                width: calc(var(--cell-size) * 0.68);
                height: calc(var(--cell-size) * 0.68);
            }
            .dock { padding: 6px 0; gap: clamp(16px, 5vmin, 28px); justify-content: space-around; width: 100%; max-width: 100%; }
        }

        /* Floating desktop install button (for cases where bottom banner is hidden or covered) */
        .desktop-install-cta {
            display: none; /* default hidden, enabled for desktop via media query */
            position: fixed;
            top: 50%;
            right: clamp(12px, 2vmin, 24px);
            transform: translateY(-50%);
            background: linear-gradient(90deg, #00D166, #00b85a);
            color: #0b2117;
            font-family: 'Mona Sans', sans-serif;
            font-weight: 900;
            letter-spacing: 0.2px;
            border: none;
            padding: 12px 18px;
            border-radius: 999px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.35);
            cursor: pointer;
            z-index: 3200; /* above overlays so it's always available */
        }
        .desktop-install-cta:hover { filter: brightness(1.05); transform: translateY(-50%) scale(1.03); }
        @media (min-width: 768px) { .desktop-install-cta { display: inline-flex; align-items: center; gap: 8px; } }

        /* If you need the dock to always stack vertically, add the `column` class
           to the dock element: <div class="dock column" id="dock">. This rule
           forces a vertical, scrollable column even on desktop (overrides
           media-query horizontal rules). */
        .dock.column {
            flex-direction: column !important;
            flex-wrap: nowrap !important;
            align-items: center !important;
            justify-content: center !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            max-width: 360px !important;
            padding: 8px 6px !important;
        }
        .dock.column .block-shape {
            display: grid !important;
            width: auto !important;
            height: auto !important;
        }
        .dock.column .block-cell {
            width: calc(var(--cell-size) * 0.86) !important;
            height: calc(var(--cell-size) * 0.86) !important;
        }

        /* REDESIGN START SCREEN STYLES */
        .redesign-start {
            background: 
                radial-gradient(circle at center, #1b5e20 0%, #05190b 100%),
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px) !important;
            background-size: 100% 100%, 40px 40px, 40px 40px !important;
            background-position: center center !important;
            backdrop-filter: none !important;
            overflow: hidden; /* Ensure decorations don't cause scroll */
        }

        .decor-block {
            position: absolute;
            z-index: 0;
            opacity: 0.15;
            pointer-events: none;
            display: grid;
            gap: 2px;
        }
        .decor-block .cell {
            width: 30px; height: 30px;
            background: rgba(255, 255, 255, 0.221);
            border-radius: 4px;
            box-shadow: none;
        }
        /* Positions */
        .decor-1 { top: 15%; left: 8%; animation: float-1 6s infinite ease-in-out; }
        .decor-2 { bottom: 20%; right: 8%; animation: float-2 7s infinite ease-in-out; }
        .decor-3 { top: 25%; right: 15%; animation: float-3 8s infinite ease-in-out; }
        .decor-4 { bottom: 15%; left: 15%; animation: float-4 9s infinite ease-in-out; }
        .decor-5 { top: 10%; right: 35%; animation: float-5 10s infinite ease-in-out; }
        .decor-6 { bottom: 35%; left: 5%; animation: float-6 8.5s infinite ease-in-out; }
        
        @keyframes float-1 { 0%,100%{transform:translateY(0) rotate(-10deg);} 50%{transform:translateY(-15px) rotate(0deg);} }
        @keyframes float-2 { 0%,100%{transform:translateY(0) rotate(15deg);} 50%{transform:translateY(-10px) rotate(5deg);} }
        @keyframes float-3 { 0%,100%{transform:translateY(0) rotate(-5deg);} 50%{transform:translateY(-15px) rotate(5deg);} }
        @keyframes float-4 { 0%,100%{transform:translateY(0) rotate(10deg);} 50%{transform:translateY(-20px) rotate(-5deg);} }
        @keyframes float-5 { 0%,100%{transform:translateY(0) rotate(45deg);} 50%{transform:translateY(-12px) rotate(30deg);} }
        @keyframes float-6 { 0%,100%{transform:translateY(0) rotate(-20deg);} 50%{transform:translateY(-18px) rotate(-10deg);} }

        /* Gift-card stack (start screen) */
        .gift-stack {
            position: absolute;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(140px, 28vmin, 340px);
            height: auto;
            z-index: 0; /* sits behind logo */
            pointer-events: none;
        }

        .gift-card {
            position: absolute;
            width: 72%;
            height: clamp(44px, 8vmin, 80px);
            border-radius: 12px;
            box-shadow: 0 18px 40px rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.35);
            overflow: hidden;
            transform-origin: center;
            background-size: cover;
            background-position: center;
        }

        .gift-card::after {
            content: '';
            position: absolute;
            left: -30%; top: -40%; width: 60%; height: 180%;
            background: linear-gradient(180deg, rgba(255,255,255,0.18), rgba(255,255,255,0.02));
            transform: rotate(-30deg);
            mix-blend-mode: overlay;
            opacity: 0.9;
            pointer-events: none;
        }

        .gift-card .card-logo {
            position: absolute;
            right: 12px;
            top: 8px;
            width: 34px;
            height: 34px;
            background-image: url('images/Logo2 - Small.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 6px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.25);
        }

        .gift-card .card-value {
            position: absolute;
            left: 14px;
            bottom: 8px;
            font-weight: 800;
            color: rgba(255,255,255,0.95);
            text-shadow: 0 2px 6px rgba(0,0,0,0.45);
            font-size: clamp(14px, 3vmin, 20px);
        }

        /* Individual cards: stacking, rotation and color gradients */
        .gift-card.g1 { z-index: 3; transform: translateX(-8%) translateY(0) rotate(-8deg) scale(1); left: 50%; background: linear-gradient(135deg,#00c853,#00e676); }
        .gift-card.g2 { z-index: 2; transform: translateX(-50%) translateY(10px) rotate(-2deg) scale(0.98); left: 50%; background: linear-gradient(135deg,#0056b3,#1e88e5); }
        .gift-card.g3 { z-index: 1; transform: translateX(-92%) translateY(22px) rotate(6deg) scale(0.96); left: 50%; background: linear-gradient(135deg,#ff9900,#ffb74d); }

        /* Subtle float to bring life */
        @keyframes card-drift { 0% { transform: translateY(0) } 50% { transform: translateY(-6px) } 100% { transform: translateY(0) } }
        .gift-card.g1 { animation: card-drift 6s ease-in-out infinite; }
        .gift-card.g2 { animation: card-drift 7s ease-in-out infinite; }
        .gift-card.g3 { animation: card-drift 8s ease-in-out infinite; }

        /* Make sure logo sits above the stack */
        .redesign-start .logo { position: relative; z-index: 2; width: clamp(200px, 40vmin, 280px); margin-bottom: 20px; }

        .game-title {
            font-size: 48px;
            font-weight: 900;
            color: #ffffff;
            text-transform: uppercase;
            text-shadow: 0 4px 12px rgba(0,0,0,0.5);
            margin: 0 0 20px 0;
            letter-spacing: 1px;
        }

        .features-list {
            list-style: none;
            padding: 0;
            margin: 0 0 30px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }

        .features-list li {
            display: flex;
            align-items: center;
            font-size: 24px;
            font-weight: 800;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .features-list .dot {
            width: 12px;
            height: 12px;
            background-color: #00e676;
            border-radius: 50%;
            margin-right: 12px;
            box-shadow: 0 0 8px #00e676;
        }

        .earn-title {
            font-size: 36px;
            color: #ffffff;
            margin: 0 0 40px 0;
            text-shadow: 0 4px 8px rgba(0,0,0,0.6);
            font-weight: 800;
        }
        
        .tap-play-btn {
            background: linear-gradient(90deg, #00e676, #ccff90, #00e676);
            background-size: 200% auto;
            color: #052e16;
            font-size: 24px;
            font-weight: 900;
            text-transform: uppercase;
            border: 4px solid #ffffff;
            border-radius: 999px;
            padding: 22px 70px;
            cursor: pointer;
            box-shadow: 
                0 10px 40px rgba(0, 230, 118, 0.6), 
                0 0 0 6px rgba(255, 255, 255, 0.2), 
                inset 0 2px 0 rgba(255,255,255,0.5);
            transition: transform 0.2s, box-shadow 0.2s, filter 0.2s;
            letter-spacing: 1.5px;
            animation: gradient-move 3s linear infinite, heartbeat 1.5s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        .tap-play-btn::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transform: skewX(-20deg);
            animation: btn-shine 3s infinite;
        }

        .tap-play-btn:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 15px 35px rgba(0, 230, 118, 0.7);
            filter: brightness(1.1);
        }

        @keyframes btn-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        @keyframes btn-shine {
            0%, 60% { left: -100%; }
            100% { left: 200%; }
        }

        /* NEW HUD DESIGN */
        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: clamp(12px, 3vmin, 24px) !important;
            width: var(--grid-size);
            max-width: 100%;
            margin: 0 auto;
            padding: 0 4px;
            box-sizing: border-box;
        }

        .hud-item {
            position: relative;
            /* slightly darker base */
            background: linear-gradient(180deg, rgba(0,0,0,0.08), rgba(0,0,0,0.16));
            border: 1px solid rgba(0,0,0,0.18);
            border-radius: 14px;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 14px;
            min-width: 150px;
            box-shadow: 0 12px 34px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.01);
            backdrop-filter: blur(6px) saturate(1.05);
            transition: transform 200ms cubic-bezier(.2,.9,.3,1), box-shadow 200ms ease;
            overflow: hidden;
        }

        .hud-item::before {
            content: '';
            position: absolute;
            left: 0; top: 0; right: 0;
            height: 32%;
            background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
            mix-blend-mode: overlay;
            pointer-events: none;
            opacity: 0.9;
        }

        .hud-item:hover {
            transform: translateY(-6px);
            box-shadow: 0 20px 46px rgba(0,0,0,0.5);
        }

        .hud-icon {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(0,0,0,0.08));
            box-shadow: inset 0 -3px 8px rgba(0,0,0,0.25), 0 6px 18px rgba(0,0,0,0.12);
            font-size: 20px;
        }

        .hud-text { display: flex; flex-direction: column; align-items: flex-start; line-height: 1.05; min-width: 0; }

        .hud-label {
            font-size: 11px;
            text-transform: uppercase;
            color: #bcd8c1;
            font-weight: 800;
            letter-spacing: 0.6px;
            margin-bottom: 2px;
        }

        .hud-value {
            font-size: clamp(20px, 3.6vmin, 30px);
            font-weight: 900;
            color: #ffffff;
            text-shadow: 0 6px 18px rgba(0,0,0,0.45);
            display: inline-block;
            font-variant-numeric: tabular-nums;
            transform-origin: center;
        }

        /* color accents for specific values */
        #timer.hud-value { color: #ffd54f; text-shadow: 0 6px 18px rgba(255,213,79,0.35); }
        #score.hud-value { color: #00ff9a; text-shadow: 0 6px 18px rgba(0,255,154,0.28); }

        /* pop animation used when values update */
        @keyframes value-pop { 0%{ transform: scale(0.9); opacity: 0.6 } 60%{ transform: scale(1.08); opacity: 1 } 100%{ transform: scale(1); } }
        .hud-value.pop { animation: value-pop 420ms cubic-bezier(.2,.9,.3,1); }

        #timer { color: #ffd54f; text-shadow: 0 6px 18px rgba(255,213,79,0.35); }
        #score { color: #00ff9a; text-shadow: 0 6px 18px rgba(0,255,154,0.28); }

        /* Floating text animation */
        .floating-text {
            position: absolute;
            color: #ffeb3b;
            font-size: 48px;
            font-weight: 900;
            text-shadow: 0 4px 8px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 100;
            animation: floatUp 1s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -150%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -200%) scale(1); opacity: 0; }
        }
        /* Removed extra mobile-scaling overrides  bottom margin kept below */
        /* Keep a consistent bottom margin so content doesn't touch screen edge */
        #game-container { margin-bottom: calc(32px + env(safe-area-inset-bottom, 0px)) !important; }

        /* Push content slightly upward on small screens while keeping substantial bottom margin */
        @media (max-width: 600px) {
            #game-container {
                justify-content: flex-start !important;
                padding-top: 1vh !important;
            }
        }

        /* Headline above grid */
        .headline { text-align: center; margin: 4px 0 6px; line-height: 1.05; }
        .headline .line1 { color: #ffffff; font-weight: 900; font-size: clamp(22px, 6.2vmin, 28px); text-shadow: 0 3px 8px rgba(0,0,0,0.45); }
        .headline .line2 { color: #00e676; font-weight: 900; font-size: clamp(22px, 6.2vmin, 28px); text-shadow: 0 3px 8px rgba(0,0,0,0.45); }

        /* Compact HUD (smaller, no icons) */
        .hud-item.compact { flex: 0 0 auto; padding: 6px 10px; gap: 6px; min-width: clamp(130px, 24vmin, 190px); border-radius: 10px; min-height: 40px; }
        .hud-item.compact .hud-label { font-size: 10px; margin-bottom: 0; opacity: 0.9; }
        .hud-item.compact .hud-value { font-size: clamp(18px, 3.2vmin, 24px); }
        /* Ensure both values use identical sizing and no extra animations */
        .hud-item .hud-value#timer, .hud-item .hud-value#score { font-size: clamp(18px, 3.2vmin, 24px) !important; animation: none !important; }

        /* Square HUD cards: equal width/height, stacked label/value */
        .hud-item.square {
            --hud-size: clamp(56px, 10vmin, 80px);
            width: var(--hud-size);
            height: var(--hud-size);
            border-radius: 30px;
            padding: 3px 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            flex: 0 0 auto; /* prevent stretching */
            min-width: 0; max-width: none;
        }
        .hud-item.square .hud-text { align-items: center; text-align: center; }
        .hud-item.square .hud-label { font-size: 10px; letter-spacing: 0.6px; }
        .hud-item.square .hud-value { font-size: clamp(14px, 3vmin, 20px); }

        /* Tutorial micro-animations */
        .tutorial-floats { position: absolute; inset: 0; pointer-events: none; overflow: hidden; z-index: 0; }
        .tutorial-floats .float { position: absolute; top: 110%; opacity: 0.35; animation-name: floatY; animation-timing-function: linear; animation-iteration-count: infinite; filter: drop-shadow(0 8px 16px rgba(0,0,0,0.35)); }
        .tutorial-floats .coin { border-radius: 50%; }
        .tutorial-floats .dollar { color: #c8ff7d; font-weight: 900; text-shadow: 0 4px 10px rgba(0,0,0,0.6); }
        @keyframes floatY {
            0%   { transform: translateY(0) translateX(0); opacity: 0; }
            8%   { opacity: 0.35; }
            92%  { opacity: 0.35; }
            100% { transform: translateY(-140%) translateX(0); opacity: 0; }
        }
        .tutorial-banner {
            left: 50%; top: 50%; transform: translate(-50%, -50%);
            background: #3ccc65d8;
            color: #0b2117;
            font-weight: 900;
            font-size: clamp(18px, 3.6vmin, 28px);
            letter-spacing: .5px;
            border-radius: 22px;
            padding: 10px 22px;
            box-sizing: border-box; /* ensure JS width includes padding */
            box-shadow: 0 16px 46px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.35);
            z-index: 3600;
            text-align: center;
            margin-bottom: 72px; /* lift above dock without overshooting */
            pointer-events: none;
            max-width: 92vw;
            min-width: 220px;
        }

        /* tutorial banner entrance */
        .tutorial-banner.animate {
            animation: tut-banner-pop 760ms cubic-bezier(.2,.9,.25,1);
        }
        @keyframes tut-banner-pop {
            0% { transform: translate(-50%, -40%) scale(0.96); opacity: 0; }
            60% { transform: translate(-50%, -52%) scale(1.02); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* pointer idle bob while waiting (slower for clearer pacing) */
        #tutorial-pointer.idle { animation: pointer-bob 2.4s ease-in-out infinite; }
        @keyframes pointer-bob { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .demo-cell {
            width:38px;height:38px;border-radius:50%;
            background:rgba(136,255,160,0.13);
            box-shadow:0 0 0 1px #32ef73cc inset;
        }
        .demo-cell.filled {
            background-image: url('images/imagSe.png');
            background-size: cover;
            background-color: transparent;
            box-shadow: 0 6px 16px rgba(0,255,128,0.25), 0 0 8px rgba(0,0,0,0.2) inset;
        }
        .demo-cell.clearing { animation: tut-clear 320ms ease-out; }
        @keyframes tut-clear {
            0% { filter: brightness(2); transform: scale(1.08); }
            100% { transform: scale(0.9); opacity: 0.3; }
        }
        #tutorial-pop-score.show { animation: tut-pop 1400ms ease-out forwards; }
        #tutorial-pop-time.show { animation: tut-pop 1400ms ease-out 180ms forwards; }
        @keyframes tut-pop {
            0% { opacity: 0; transform: translate(-50%, -40%) scale(0.85); }
            40% { opacity: 1; transform: translate(-50%, -80%) scale(1.08); }
            100% { opacity: 0; transform: translate(-50%, -120%) scale(1); }
        }

        /* Ghost piece that animates over the REAL grid */
        .tutorial-ghost {
            position: fixed;
            z-index: 4000; /* above overlay for visibility */
            display: grid;
            transition: left 1400ms cubic-bezier(.22,.9,.26,1), top 1400ms cubic-bezier(.22,.9,.26,1), transform 700ms ease, opacity 700ms ease;
            filter: drop-shadow(0 12px 30px rgba(0,0,0,0.45));
            will-change: left, top, transform, opacity;
        }
        .tutorial-ghost .ghost-cell {
            border-radius: 50%;
            background-image: url('images/imagSe.png');
            background-size: cover;
            background-color: transparent;
            box-shadow: 0 8px 22px rgba(0,255,128,0.28), 0 0 10px rgba(0,0,0,0.22) inset;
        }

        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(6,18,12,0.32);
            z-index: 5000;
            backdrop-filter: blur(0px) saturate(1.02);
            -webkit-backdrop-filter: blur(0px) saturate(1.02);
            will-change: backdrop-filter, opacity;
            animation: loading-enter 520ms cubic-bezier(.2,.9,.25,1) forwards;
        }

        @keyframes loading-enter {
            0% { opacity: 0; backdrop-filter: blur(0px) saturate(1); background: rgba(6,18,12,0.0); }
            100% { opacity: 1; backdrop-filter: blur(8px) saturate(1.04); background: rgba(6,18,12,0.54); }
        }

        .loading-logo { width: clamp(180px, 34vmin, 320px); height: auto; animation: load-pulse 1.6s ease-in-out infinite, load-glow 1.6s ease-in-out infinite; filter: drop-shadow(0 14px 36px rgba(0,0,0,0.38)); }
        @keyframes load-pulse { 0%,100%{ transform: scale(1); opacity: 0.96 } 50% { transform: scale(1.12); opacity: 1 } }
        @keyframes load-glow { 0% { filter: drop-shadow(0 12px 28px rgba(0,0,0,0.38)) drop-shadow(0 0 0 rgba(0,230,118,0)); } 50% { filter: drop-shadow(0 20px 46px rgba(0,230,118,0.22)) drop-shadow(0 0 18px rgba(72,255,59,0.18)); } 100% { filter: drop-shadow(0 12px 28px rgba(0,0,0,0.38)) drop-shadow(0 0 0 rgba(0,230,118,0)); } }

        /* stronger, slower brand pulse while preparing tutorial */
        #loading-overlay.prep .loading-logo { animation-duration: 1.8s; transform-origin: center; }

        /* Loading message under the logo (two-line headline) */
        .loading-message-wrapper { margin-top: 18px; text-align: center; pointer-events: none; }
        .loading-line1, .loading-line2 {
            font-family: 'Mona Sans', 'Helvetica', sans-serif;
            font-weight: 900;
            text-shadow: 0 6px 18px rgba(0,0,0,0.6);
            letter-spacing: 0.4px;
            opacity: 0;
            transform: translateY(6px) scale(0.998);
            animation: loading-msg-in 520ms cubic-bezier(.2,.9,.25,1) forwards 200ms;
        }
        .loading-line1 { color: #e9fff0; font-size: clamp(28px, 4.8vmin, 28px); }
        .loading-line2 { font-size: clamp(28px, 8vmin, 48px); margin-top: 2px; color: #00e676; background: linear-gradient(90deg,#00e676,#00b85a); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; }

        /* Mini reward popup shown when player scores during gameplay */
        .mini-reward {
            position: fixed;
            pointer-events: none;
            z-index: 4500;
            transform-origin: center;
            opacity: 0;
            /* anchor center horizontally and start slightly below center for pop */
            transform: translate(-50%, 6px) scale(0.98);
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
            padding: 8px 12px;
            border-radius: 14px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.42), inset 0 1px 0 rgba(255,255,255,0.02);
            backdrop-filter: blur(6px) saturate(1.1);
            color: #fff;
            min-width: 96px;
            align-items: center;
        }
        .mini-reward .mr-amount { font-weight:900; font-size:16px; color:#ffeb3b; text-shadow:0 6px 10px rgba(0,0,0,0.45); }
        .mini-reward .mr-time { font-weight:800; font-size:13px; color:#71f588; margin-left:6px; }
        .mini-reward .mr-dollar { font-weight:900; color:#fff; font-size:14px; margin-left:6px; }

        /* compact variant used for simple placement feedback */
        .mini-reward.compact { background: transparent; padding: 6px 8px; border-radius: 8px; box-shadow: none; min-width: 0; }
        .mini-reward.compact .mr-amount { font-size:20px; color:#fff; text-shadow:0 6px 16px rgba(0,0,0,0.6); }
        .mini-reward.compact .mr-time, .mini-reward.compact .mr-dollar { display: none; }
        .mini-reward.show { animation: mini-reward-pop 1400ms cubic-bezier(.2,.9,.25,1) forwards; }
        @keyframes mini-reward-pop {
            0% { transform: translate(-50%, 6px) scale(0.98); opacity: 0; }
            20% { transform: translate(-50%, 0px) scale(1.06); opacity: 1; }
            70% { transform: translate(-50%, -34px) scale(1); opacity: 0.95; }
            100% { transform: translate(-50%, -66px) scale(0.96); opacity: 0; }
        }
        @keyframes loading-msg-in { 0% { opacity: 0; transform: translateY(10px) scale(0.996); } 100% { opacity: 1; transform: translateY(0) scale(1); } }

        /* Global floating money background */
        .bg-floats { position: fixed; inset: 0; pointer-events: none; z-index: 0; overflow: hidden; }
        .bg-floats .float { position: absolute; top: 110%; opacity: 0.18; filter: drop-shadow(0 8px 18px rgba(0,0,0,0.35)); will-change: transform, opacity; }
        .bg-floats .coin { width: 28px; height: 28px; border-radius: 50%; background: url('images/imagSe.png') center/cover no-repeat; }
        .bg-floats .dollar { color: #c8ff7d; font-weight: 900; text-shadow: 0 4px 10px rgba(0,0,0,0.6); font-size: 24px; }

        /* Add a gentle horizontal sway on top of vertical float */
        .float.sway { animation-name: floatY, floatSway; animation-timing-function: linear, ease-in-out; animation-iteration-count: infinite, infinite; }
        @keyframes floatSway { 0% { transform: translateX(0) rotate(0deg); } 50% { transform: translateX(6px) rotate(-3deg); } 100% { transform: translateX(0) rotate(0deg); } }
    </style>
</head>
<style>
    /* Small-screen adjustments: scale down content instead of reflowing layout */
    @media (max-width: 780px) {
        :root {
            --gap: 0.6vmin;
            --grid-size: calc(min(60vmax, 420px));
            --cell-size: calc((var(--grid-size) - (9 * var(--gap))) / 8);
        }
        .logo {
            width: min(12vmin, 90px);
        }
        .hud-item {
            padding: 8px 12px;
            font-size: clamp(12px, 2.5vmin, 14px);
        }
        .hud-value {
            font-size: clamp(14px, 2.5vmin, 22px);
        }
        #start-screen .logo, #game-over .logo { width: clamp(180px, 30vmin, 420px); }
        .grid-container {
            width: var(--grid-size);
            height: var(--grid-size);
        }
        .dock {
            gap: 8px;
        }
        .dock .block-cell {
            width: calc(var(--cell-size) * 0.8);
            height: calc(var(--cell-size) * 0.8);
        }
        /* Ensure the grid itself scales with the viewport instead of pushing content aside */
        .grid-container {
            transform: scale(0.9);
            transform-origin: center;
        }
    }
</style>
<body>

        <!-- Loading overlay (shown until assets are preloaded) -->
        <div id="loading-overlay">
            <img src="images/Logo.png" alt="HeyCash" class="loading-logo">
            <div class="loading-message-wrapper">
                <div class="loading-line1">Earn Money By</div>
                <div class="loading-line2">Playing  Games!</div>
            </div>
        </div>

        <!-- Global floating money background -->
        <div class="bg-floats" aria-hidden="true">
            <div class="float coin" style="left:6%; animation-duration: 22s; animation-delay: -3s;"></div>
            <div class="float dollar" style="left:14%; animation-duration: 26s; animation-delay: -9s; font-size:22px;">$</div>
            <div class="float coin" style="left:26%; animation-duration: 18s; animation-delay: -6s; width:24px; height:24px;"></div>
            <div class="float dollar" style="left:38%; animation-duration: 24s; animation-delay: -12s; font-size:26px;">$</div>
            <div class="float coin" style="left:52%; animation-duration: 20s; animation-delay: -4s;"></div>
            <div class="float dollar" style="left:64%; animation-duration: 28s; animation-delay: -14s; font-size:28px;">$</div>
            <div class="float coin" style="left:78%; animation-duration: 23s; animation-delay: -7s; width:32px; height:32px;"></div>
            <div class="float dollar" style="left:90%; animation-duration: 25s; animation-delay: -11s; font-size:24px;">$</div>
        </div>

        <!-- Tutorial overlay shown before game starts (auto-advances, first-load only) -->
        <div id="tutorial-overlay" style="display: none; position: fixed; z-index: 3000; top:0; left:0; width:100vw; height:100vh; background:rgba(12, 52, 22, 0.325); align-items: center; justify-content:center; flex-direction:column;">
            <!-- Floating background coins and $ -->
            <div class="tutorial-floats" aria-hidden="true">
                <img class="float coin" src="images/imagSe.png" style="left:8%; animation-duration: 16s; animation-delay: -3s; width:32px; height:32px;" alt="">
                <div class="float dollar" style="left:22%; animation-duration: 18s; animation-delay: -6s; font-size:28px;">$</div>
                <img class="float coin" src="images/imagSe.png" style="left:38%; animation-duration: 14s; animation-delay: -9s; width:28px; height:28px; opacity:.3;" alt="">
                <div class="float dollar" style="left:56%; animation-duration: 20s; animation-delay: -2s; font-size:24px; opacity:.28;">$</div>
                <img class="float coin" src="images/imagSe.png" style="left:72%; animation-duration: 17s; animation-delay: -11s; width:36px; height:36px;" alt="">
                <div class="float dollar" style="left:86%; animation-duration: 15s; animation-delay: -5s; font-size:32px;">$</div>
                <img class="float coin" src="images/imagSe.png" style="left:90%; animation-duration: 22s; animation-delay: -13s; width:26px; height:26px; opacity:.28;" alt="">
            </div>
            <!-- Banner over the real grid -->
            <div id="tutorial-banner" class="tutorial-banner">Drag Blocks To Earn Your First Reward!</div>
            <!-- Hand pointer that moves from dock to grid -->
            <img id="tutorial-pointer" src="images/hand.png" style="width:228px;position:fixed;left:-240px;top:-240px;opacity:0.98;z-index:4000;transition:left 1.6s cubic-bezier(.25,.9,.26,1), top 1.6s cubic-bezier(.25,.9,.26,1);filter:drop-shadow(0 16px 44px rgba(0,0,0,0.6));transform-origin:center;" alt="pointer">
            <!-- Reward pop texts centered on real grid -->
            <div id="tutorial-pop-score" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);color:#ffeb3b;font-weight:900;font-size:32px;opacity:0;text-shadow:0 4px 8px rgba(0,0,0,.5);pointer-events:none;z-index:4000;">+100</div>
            <div id="tutorial-pop-time" style="position:fixed;left:52%;top:56%;transform:translate(-50%,-50%);color:#71f588;font-weight:900;font-size:24px;opacity:0;text-shadow:0 4px 8px rgba(0,0,0,.5);pointer-events:none;z-index:4000;">+2s</div>
            <button id="tutorial-cta" onclick="tutorialNextStep()" style="margin-top:44px;font-size:clamp(22px,5vw,26px);background:linear-gradient(90deg,#01e991 80%,#38ff4f 110%);border:none;border-radius:2em;letter-spacing:1.2px;font-weight:900;color:#175e35;box-shadow:0 10px 40px #14e35b32;padding:20px 54px;cursor:pointer;display:none;">Start Playing</button>
        </div>
        <div id="game-container">
        <img src="images/Logo.png" alt="HeyCash Logo" class="logo" style="width: clamp(420px, 40vmin, 700px); max-width: 60%; height: auto;">
        
        <div class="play-area">
            <div class="headline">
                <div class="line1">Earn Money By</div>
                <div class="line2">Playing Games!</div>
            </div>

            <div class="hud-row">
                <div class="hud-item compact square">
                    <div class="hud-text">
                        <span class="hud-label">Time</span>
                        <span class="hud-value" id="timer">60</span>
                    </div>
                </div>
                
                <div class="hud-item compact square">
                    <div class="hud-text">
                        <span class="hud-label">Score</span>
                        <span class="hud-value" id="score">0</span>
                    </div>
                </div>
            </div>

            <div class="grid-container" id="grid"></div>

            

            <div class="dock" id="dock"></div>
        </div>
    </div>

    <div class="mobile-banner" id="mobile-banner" style="display:none;" onclick="installApp()">
        <div class="mobile-left">
            <img src="images/Logo2 - Small.png" alt="HeyCash small logo" class="mobile-side-logo">
            <div class="mobile-text">
                <div class="mobile-title">HEYCA$H</div>
                <div class="mobile-sub">Play &amp; Earn Rewards</div>
            </div>
        </div>

        <div class="gift-cards-icon" aria-hidden="true">
            <!-- Enhanced mobile gift cards (use smaller variants and badge) -->
            <div class="gift-card g1"><div class="card-logo" aria-hidden="true"></div></div>
            <div class="gift-card g2"><div class="card-logo" aria-hidden="true"></div></div>
            <div class="gift-card g3"><div class="card-logo" aria-hidden="true"></div></div>
        </div>

        <div id="mobile-dock" class="mobile-dock" aria-hidden="false"></div>
        <img src="images/install-cta.png" class="mobile-install-img" id="mobile-install" alt="Install HeyCash" aria-label="Install HeyCash">
    </div>

    <!-- Start screen removed: game starts immediately -->

<div id="game-over" class="overlay">
    <div class="sun-rot" aria-hidden="true"></div>
    <img src="images/Logo.png" alt="HeyCash Logo" class="logo">
    <h1>Congratulations!</h1>
    
    <div class="reward-card">
        <div class="reward-text">You earned</div>
        
        <div class="reward-display">
            <div class="reward-display-left">
                <div class="reward-display-logo">
                    <img src="images/paypal.png" alt="PayPal">
                </div>
                <div class="reward-display-label">PayPal</div>
            </div>
            <div class="reward-display-amount">$<span id="final-reward">17</span></div>
        </div>

        <div class="more-cards" aria-hidden="true">
            <div class="card-fake green"></div>
            <div class="card-fake black"></div>
            <div class="card-fake gray"></div>
        </div>
    </div>
    
        <button class="reward-btn" onclick="installApp()">
            <span class="reward-btn-text">CLAIM REWARD</span>
            <img class="reward-img" src="images/Group 9.png" alt="Claim Reward">
        </button>
</div>


    <script>
        /* =========================================
           1. ASSET CONFIGURATION (User Editable)
           ========================================= 
           Paste your Base64 strings inside the quotes.
           If left empty (''), it will use the fallback HEX color.
        */
        
        const ASSETS = {
            // Background Image (Optional)
            backgroundImage: '', 

            // Block Textures (Mapped to the 5 colors)
            // Example: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg=='
            textures: [
                'images/imagSe.png',
                'images/imagSe.png',
                'images/imagSe.png',
                'images/imagSe.png',
                'images/imagSe.png'
            ]
        };

        const INSTALL_URL = "https://google.com"; // REPLACE WITH YOUR APP STORE URL

        /* =========================================
           2. MRAID & AD LOGIC
           ========================================= */
        
        let mraidReady = false;

        function initMraid() {
            if (typeof mraid === 'undefined') {
                console.log("MRAID not found - Running in standalone mode");
                return;
            }
            
            if (mraid.getState() === 'loading') {
                mraid.addEventListener('ready', () => {
                    mraidReady = true;
                    console.log("MRAID Ready");
                });
            } else {
                mraidReady = true;
            }
        }

        function installApp() {
            if (typeof mraid !== 'undefined' && mraidReady) {
                mraid.open(INSTALL_URL);
            } else {
                window.open(INSTALL_URL, '_blank');
            }
        }

        initMraid();

        /* =========================================
           PREVENT ZOOM ON DESKTOP
           ========================================= */
        
        // Prevent keyboard zoom (Ctrl/Cmd +, -, 0)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '0' || e.key === '=')) {
                e.preventDefault();
            }
        }, false);

        // Prevent mouse wheel zoom (Ctrl/Cmd + scroll)
        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
            }
        }, { passive: false });

        // Prevent pinch zoom on trackpad
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        }, false);

        // Reset zoom to 100% on load and periodically
        window.addEventListener('load', () => {
            document.body.style.zoom = '1';
        });

        window.addEventListener('resize', () => {
            document.body.style.zoom = '1';
        });

        /* =========================================
           3. GAME LOGIC
           ========================================= */

        const GRID_SIZE = 8;
        const INITIAL_TIME = 25;
        let isTutorialActive = false; // gate interactions and scoring during tutorial
        
        // Colors (Fallback if no Base64 texture provided)
        const COLORS = [
            '#bf616a', '#ebcb8b', '#a3be8c', '#b48ead', '#88c0d0'
        ];

        // Standard Tetris-ish shapes - Simplified for easier scoring
        const SHAPES = [
            [[1]], [[1]], [[1,1]], [[1,1]], [[1,1,1]], [[1,1,1]], 
            [[1,1,1]], [[1,1,1,1]], [[1,1],[1,1]], [[1,1,1],[0,1,0]]
        ];

        // Restricted set for the dock: only T and L-shaped pieces (various rotations)
        const DOCK_SHAPES = [
            // T variants
            [[1,1,1],[0,1,0]],
            [[0,1,0],[1,1,1]],
            [[1,0],[1,1],[1,0]],
            [[0,1],[1,1],[0,1]],
            // L variants (and mirrored)
            [[1,0],[1,0],[1,1]],
            [[0,1],[0,1],[1,1]],
            [[1,1],[1,0],[1,0]],
            [[1,1],[0,1],[0,1]]
        ];

        // Additional common forms: 2x2 square, 3-long line (horiz/vert), small 3-block Ls
        // These match the illustrative forms the user provided
        DOCK_SHAPES.push(
            [[1,1],[1,1]],      // 2x2 square
            [[1,1,1]],           // 3-long horizontal
            [[1],[1],[1]],      // 3-long vertical
            [[1,1,0],[0,1,1]],  // small zig-zag (S/Z)
            [[1,0],[1,0],[1,0]] // 3x1 vertical fallback (redundant but safe)
        );

        let gridState = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

        // Pre-fill some blocks so there are already pieces in the grid on load
        // All pre-filled cells use texture index 2 (which maps to Logo2 - Small.png)
        // Pre-fill inspired by reference: top blocks on left + right columns
        const PRE_FILL = [];
        // fill rows 0..2 on columns 0..2 and 5..7
        for (let r=0; r<=2; r++) {
            for (let c=0; c<=2; c++) PRE_FILL.push([r,c]);
            for (let c=5; c<=7; c++) PRE_FILL.push([r,c]);
        }
        // add a small shape near row 3 center-top
        PRE_FILL.push([3,3],[3,4]);
        PRE_FILL.forEach(([r,c]) => { gridState[r][c] = 2; });
        let score = 0;
        let timeLeft = INITIAL_TIME;
        let timerInterval;
        let isGameActive = false;

        const gridEl = document.getElementById('grid');
        const dockEl = document.getElementById('dock');
        let scoreEl = document.getElementById('score');
        let timerEl = document.getElementById('timer');
        const mainHeaderLogo = document.querySelector('#game-container > .logo');

        // Apply Background Asset if present
        if(ASSETS.backgroundImage) {
            document.body.style.backgroundImage = `url('${ASSETS.backgroundImage}')`;
            document.body.style.backgroundSize = 'cover';
        }

        function initGame() {
            createGrid();
            // bind HUD elements above the grid
            scoreEl = document.getElementById('score');
            timerEl = document.getElementById('timer');
            updateGridVisuals(); // reflect pre-filled cells immediately
        }

        // Called only after user clicks "Tap to Play"
        function userInteractStart() {
            const startEl = document.getElementById('start-screen');
            if (startEl) startEl.style.display = 'none';
            // ensure the main in-layout logo is visible
            if (mainHeaderLogo) mainHeaderLogo.style.display = '';
            isGameActive = true;
            // Do not automatically show the bottom banner here  it will be visible during tutorial and hidden after
            // (keeps the banner DOM loaded but avoids re-showing it after tutorial)
            spawnBlocks();
            startTimer();
        }

        function createGrid() {
            gridEl.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    gridEl.appendChild(cell);
                }
            }
        }

        function createBlockElement(matrix) {
            const colorIdx = Math.floor(Math.random() * COLORS.length);
            const color = COLORS[colorIdx];
            const texture = ASSETS.textures[colorIdx];

            const container = document.createElement('div');
            container.classList.add('block-shape');
            container.style.gridTemplateColumns = `repeat(${matrix[0].length}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${matrix.length}, 1fr)`;
            
            matrix.forEach(row => {
                row.forEach(val => {
                    const cell = document.createElement('div');
                    if (val) {
                        cell.classList.add('block-cell');
                        if (texture) {
                            cell.style.backgroundImage = `url('${texture}')`;
                            cell.style.backgroundColor = 'transparent';
                        } else {
                            cell.style.backgroundColor = color;
                        }
                    }
                    container.appendChild(cell);
                });
            });

            container.matrix = matrix;
            container.colorIdx = colorIdx; // Store index to retrieve texture later
            addDragLogic(container);
            return container;
        }

        function spawnBlocks() {
            // Always use the main dock so pieces appear in the blank space below the grid
            const targetDock = dockEl;
            targetDock.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const shape = DOCK_SHAPES[Math.floor(Math.random() * DOCK_SHAPES.length)];
                targetDock.appendChild(createBlockElement(shape));
            }
        }

        /* --- DRAG SYSTEM --- */
        function addDragLogic(el) {
            let startX, startY;

            const onDown = (e) => {
                if(!isGameActive) return;
                e.preventDefault();
                
                // 1. Calculate all geometry while element is still in its original context
                const rect = el.getBoundingClientRect();
                const firstCell = gridEl.querySelector('.cell');
                const gridCellSize = firstCell ? firstCell.getBoundingClientRect().width : 0;
                const blockCell = el.querySelector('.block-cell');
                const blockCellSize = blockCell ? blockCell.getBoundingClientRect().width : rect.width;
                const scale = gridCellSize / blockCellSize;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                // 2. Save original parent info so we can return it later if needed
                el._originalParent = el.parentElement;
                el._originalNext = el.nextElementSibling;

                // 3. Move to body to escape any CSS transforms (like in landscape mode)
                el.classList.add('dragging');
                document.body.appendChild(el);

                // 4. Apply geometry
                el.style.position = 'fixed';
                el.style.left = rect.left + 'px';
                el.style.top = rect.top + 'px';
                // Force size using the calculated scale, so it matches the grid
                el.style.width = (rect.width * scale) + 'px';
                el.style.height = (rect.height * scale) + 'px';
                el.style.transform = '';

                // Record pointer offset relative to element top-left
                startX = clientX - rect.left;
                startY = clientY - rect.top;

                moveAt(clientX, clientY);

                // Bind Move/Up
                document.addEventListener('mousemove', onMove);
                document.addEventListener('touchmove', onMove, {passive: false});
                document.addEventListener('mouseup', onUp);
                document.addEventListener('touchend', onUp);
            };

            const moveAt = (x, y) => {
                el.style.left = (x - startX) + 'px';
                el.style.top = (y - startY) + 'px';
            };

            const onMove = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                moveAt(clientX, clientY);
                // store last pointer position for touchend/mouseup fallbacks
                window._lastPointerX = clientX;
                window._lastPointerY = clientY;
                // show potential placement while dragging
                try {
                    const gridRect = gridEl.getBoundingClientRect();
                    const cellRect = gridEl.querySelector('.cell').getBoundingClientRect();
                    const cellSize = cellRect.width;
                    const gap = parseFloat(getComputedStyle(gridEl).gap);
                    const padding = parseFloat(getComputedStyle(gridEl).padding);
                    const totalCellSize = cellSize + gap;
                    // Use the pointer coordinates (clientX/clientY) for center calculation
                    const centerX = clientX - gridRect.left - padding;
                    const centerY = clientY - gridRect.top - padding;
                    const baseCol = Math.round((centerX - cellSize*0.5) / totalCellSize);
                    const baseRow = Math.round((centerY - cellSize*0.5) / totalCellSize);
                    // find first valid in neighborhood and highlight
                    let shown = false;
                    for (let dr=-1; dr<=1 && !shown; dr++){
                        for (let dc=-1; dc<=1 && !shown; dc++){
                            const r = baseRow + dr;
                            const c = baseCol + dc;
                            if (canPlace(el.matrix, r, c)){
                                showHighlight(el.matrix, r, c);
                                shown = true;
                            }
                        }
                    }
                    if (!shown) clearHighlights();
                } catch (err){}
            };

            // Track and show possible placement highlight while moving
            let lastHighlight = [];
            const clearHighlights = () => {
                const cells = gridEl.querySelectorAll('.cell');
                lastHighlight.forEach(idx => {
                    if (cells[idx]) cells[idx].classList.remove('highlight');
                });
                lastHighlight = [];
            };

            const showHighlight = (matrix, startRow, startCol) => {
                clearHighlights();
                if (!matrix) return;
                const cells = gridEl.querySelectorAll('.cell');
                for (let r=0;r<matrix.length;r++){
                    for (let c=0;c<matrix[0].length;c++){
                        if (matrix[r][c]===1){
                            const gr = startRow + r;
                            const gc = startCol + c;
                            if (gr>=0 && gr<GRID_SIZE && gc>=0 && gc<GRID_SIZE){
                                const idx = gr*GRID_SIZE + gc;
                                if (cells[idx]) cells[idx].classList.add('highlight');
                                lastHighlight.push(idx);
                            }
                        }
                    }
                }
            };

            const onUp = (e) => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('touchmove', onMove);
                document.removeEventListener('mouseup', onUp);
                document.removeEventListener('touchend', onUp);

                el.style.transform = '';

                // Hit Test with tolerance & neighborhood search
                const gridRect = gridEl.getBoundingClientRect();
                const cellRect = gridEl.querySelector('.cell').getBoundingClientRect();
                const cellSize = cellRect.width;
                const gap = parseFloat(getComputedStyle(gridEl).gap);
                const padding = parseFloat(getComputedStyle(gridEl).padding);
                const totalCellSize = cellSize + gap;

                // Use the event pointer (or last known position) to compute center relative to grid
                const clientX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : (e.clientX || (window._lastPointerX || 0));
                const clientY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : (e.clientY || (window._lastPointerY || 0));
                const centerX = clientX - gridRect.left - padding;
                const centerY = clientY - gridRect.top - padding;

                // Approximate base row/col
                let baseCol = Math.round((centerX - cellSize*0.5) / totalCellSize);
                let baseRow = Math.round((centerY - cellSize*0.5) / totalCellSize);

                // Search small neighborhood for a valid placement (more tolerant)
                let placed = false;
                let foundRow = 0, foundCol = 0;
                for (let dr = -1; dr <= 1 && !placed; dr++){
                    for (let dc = -1; dc <= 1 && !placed; dc++){
                        const r = baseRow + dr;
                        const c = baseCol + dc;
                        if (canPlace(el.matrix, r, c)){
                            placeBlock(el.matrix, r, c, el.colorIdx);
                            placed = true;
                            foundRow = r; foundCol = c;
                        }
                    }
                }

                clearHighlights();

                if (placed) {
                    const parentDock = el._originalParent; // Use stored parent
                    el.remove();
                    // Spawn one new block to maintain 3 pieces in the dock where it came from
                    const newShape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                    const targetDockForSpawn = parentDock && parentDock.classList.contains('mobile-dock') ? parentDock : (parentDock || dockEl);
                    targetDockForSpawn.appendChild(createBlockElement(newShape));
                } else {
                    // Reset styling
                    el.classList.remove('dragging');
                    el.style.position = '';
                    el.style.left = '';
                    el.style.top = '';
                    el.style.width = '';
                    el.style.height = '';

                    // Return to original location in DOM
                    if (el._originalParent) {
                        if (el._originalNext) {
                            el._originalParent.insertBefore(el, el._originalNext);
                        } else {
                            el._originalParent.appendChild(el);
                        }
                    } else {
                        dockEl.appendChild(el); // Fallback
                    }
                }
            };

            el.addEventListener('mousedown', onDown);
            el.addEventListener('touchstart', onDown, {passive: false});
        }

        function canPlace(matrix, startRow, startCol) {
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[0].length; c++) {
                    if (matrix[r][c] === 1) {
                        const gridR = startRow + r;
                        const gridC = startCol + c;
                        if (gridR < 0 || gridR >= GRID_SIZE || 
                            gridC < 0 || gridC >= GRID_SIZE || 
                            gridState[gridR][gridC] !== null) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeBlock(matrix, startRow, startCol, colorIdx) {
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[0].length; c++) {
                    if (matrix[r][c] === 1) {
                        gridState[startRow + r][startCol + c] = colorIdx;
                    }
                }
            }
            // award placement points (unless tutorial)
            if (!isTutorialActive) {
                const placementPoints = 25;
                score += placementPoints;
                    // show a small reward popup near the placed piece (compute center including padding/gap)
                    try {
                        const { gridRect, cellSize, gap, padding, total } = getGridMetrics();
                        const cols = matrix[0].length;
                        const rows = matrix.length;
                        const pieceLeft = gridRect.left + padding + startCol * total;
                        const pieceTop = gridRect.top + padding + startRow * total;
                        const pieceWidth = cols * cellSize + (cols - 1) * gap;
                        const pieceHeight = rows * cellSize + (rows - 1) * gap;
                        const centerX = pieceLeft + pieceWidth / 2;
                        const centerY = pieceTop + pieceHeight / 2;
                        showMiniReward(placementPoints, 0, centerX, centerY, { compact: true });
                    } catch (e) {}
            }
            updateGridVisuals();
            checkLines();
            if (!isTutorialActive) {
                scoreEl.innerText = score;
            }
        }

        function updateGridVisuals() {
            const cells = gridEl.querySelectorAll('.cell');
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const idx = r * GRID_SIZE + c;
                    const cell = cells[idx];
                    const val = gridState[r][c];

                    if (val !== null) {
                        const texture = ASSETS.textures[val];
                        const color = COLORS[val];
                        if (texture) {
                            cell.style.backgroundImage = `url('${texture}')`;
                            cell.style.backgroundColor = 'transparent';
                        } else {
                            cell.style.backgroundColor = color;
                            cell.style.backgroundImage = '';
                        }
                        cell.classList.add('has-coin');
                    } else {
                        cell.style.backgroundColor = '';
                        cell.style.backgroundImage = '';
                        cell.classList.remove('has-coin');
                    }
                }
            }
        }

        function checkLines() {
            let rowsToClear = [], colsToClear = [];

            for (let r = 0; r < GRID_SIZE; r++) {
                if (gridState[r].every(v => v !== null)) rowsToClear.push(r);
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                let full = true;
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (gridState[r][c] === null) full = false;
                }
                if (full) colsToClear.push(c);
            }

            if (rowsToClear.length > 0 || colsToClear.length > 0) {
                const cells = gridEl.querySelectorAll('.cell');
                // Animate
                rowsToClear.forEach(r => {
                    for(let c=0; c<GRID_SIZE; c++) cells[r*GRID_SIZE + c].classList.add('clearing');
                });
                colsToClear.forEach(c => {
                    for(let r=0; r<GRID_SIZE; r++) cells[r*GRID_SIZE + c].classList.add('clearing');
                });

                // Show floating text
                const lines = rowsToClear.length + colsToClear.length;
                const points = lines * 100;
                const gridRect = gridEl.getBoundingClientRect();
                // We use relative positioning inside grid container, so center is width/2, height/2
                // show a compact reward popup that includes points and time gained (only when tutorial not active)
                try {
                    if (!isTutorialActive) {
                        showMiniReward(points, lines * 2, gridRect.left + gridRect.width/2, gridRect.top + gridRect.height/2);
                    }
                } catch(e) {}

                setTimeout(() => {
                    rowsToClear.forEach(r => gridState[r].fill(null));
                    colsToClear.forEach(c => {
                        for(let r=0; r<GRID_SIZE; r++) gridState[r][c] = null;
                    });
                    
                    Array.from(cells).forEach(cell => cell.classList.remove('clearing'));
                    updateGridVisuals();
                }, 300);

                if (!isTutorialActive) {
                    score += points;
                    timeLeft += lines * 2;
                    scoreEl.innerText = score;
                    timerEl.innerText = timeLeft;
                }
                // animate value pop when points/time change
                if (!isTutorialActive) {
                    try {
                        scoreEl.classList.remove('pop');
                        void scoreEl.offsetWidth;
                        scoreEl.classList.add('pop');
                        timerEl.classList.remove('pop');
                        void timerEl.offsetWidth;
                        timerEl.classList.add('pop');
                    } catch (e) {}
                }
            }
        }

        function showFloatingText(text, x, y) {
            const el = document.createElement('div');
            el.classList.add('floating-text');
            el.innerText = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            gridEl.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // show a small rewarding popup with points and time near given screen coords
        function showMiniReward(points, timeSec, screenX, screenY, opts){
            try {
                opts = opts || {};
                const el = document.createElement('div');
                el.className = 'mini-reward' + (opts.compact ? ' compact' : '');
                const amount = document.createElement('div'); amount.className = 'mr-amount'; amount.innerText = `+${points}`;
                const t = document.createElement('div'); t.className = 'mr-time'; t.innerText = timeSec ? `+${timeSec}s` : '';
                const dollar = document.createElement('div'); dollar.className = 'mr-dollar'; dollar.innerText = '$';
                el.appendChild(amount);
                if (!opts.compact && timeSec) el.appendChild(t);
                if (!opts.compact) el.appendChild(dollar);
                // position centered on given coords
                el.style.left = (screenX) + 'px';
                el.style.top = (screenY) + 'px';
                document.body.appendChild(el);
                // force reflow then show
                void el.offsetWidth;
                el.classList.add('show');
                // cleanup after animation
                setTimeout(()=>{ try{ el.remove(); }catch(e){} }, 1600);
            } catch(e) {}
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (!isGameActive) return;
                timeLeft--;
                timerEl.innerText = timeLeft;
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

                function endGame() {
                        isGameActive = false;
                        clearInterval(timerInterval);
                        const rewardAmount = Math.floor(score / 10);
                        document.getElementById('final-reward').innerText = rewardAmount;
                        document.getElementById('game-over').style.display = 'flex';
                        const mobileBanner = document.getElementById('mobile-banner');
                        if (mobileBanner) mobileBanner.style.display = 'none';
                        // Animate bottom deck cards to move like real cards
                        try {
                            const deckCards = document.querySelectorAll('#game-over .more-cards .card-fake');
                            deckCards.forEach((card, i) => {
                                card.style.transition = 'transform 0.6s cubic-bezier(.2,.9,.3,1), opacity 0.6s';
                                card.style.transform = `translateX(-50%) translateY(${i * 6}px) rotate(${(i - 1) * -6}deg) scale(0.98)`;
                            });
                            setTimeout(() => {
                                deckCards.forEach((card, i) => {
                                    card.style.transform = `translateX(-50%) translateY(${i * 2}px) rotate(${(i - 1) * -4}deg) scale(1)`;
                                });
                            }, 400);
                        } catch (e) { /* ignore animation errors */ }
                }

        // Initialize board (but not game) on load
        // Keep mobile banner and dock responsive on resize
        window.addEventListener('resize', () => {
            // Re-evaluate whether the banner fits on screen
            try { checkAndToggleBanner(); } catch(e) {}
            // Refresh dock contents to match current layout on small debounce
            clearTimeout(window.__spawnResizeTimer);
            window.__spawnResizeTimer = setTimeout(() => {
                if (isGameActive) spawnBlocks();
            }, 120);
        });

        // Wire up mobile install button specifically (prevents accidental overlay clicks)
        const __mobileInstallBtn = document.getElementById('mobile-install');
        if (__mobileInstallBtn) {
            __mobileInstallBtn.addEventListener('click', (e) => { e.stopPropagation(); installApp(); });
            __mobileInstallBtn.setAttribute('aria-label', 'Install HeyCash');
        }

        initGame();

        // --- Tutorial logic (auto-advance + first-load only) ---
        const TUTORIAL_KEY = 'hc_tutorial_seen_v2';
        let tutorialStage = 0;
        const tutorialOverlay = document.getElementById('tutorial-overlay');
        const tutorialPointer = document.getElementById('tutorial-pointer');
        const tutorialCta = document.getElementById('tutorial-cta');
        const tutorialAnimWrap = document.getElementById('tutorial-anim-wrap');
        const tutorialBanner = document.getElementById('tutorial-banner');
        const tPopScore = document.getElementById('tutorial-pop-score');
        const tPopTime = document.getElementById('tutorial-pop-time');
        let __tutorialBackup = null;

        // Utilities for real-grid demo
        function getGridMetrics(){
            const gridRect = gridEl.getBoundingClientRect();
            const cellRect = gridEl.querySelector('.cell').getBoundingClientRect();
            const styles = getComputedStyle(gridEl);
            const gap = parseFloat(styles.gap) || 0;
            const padding = parseFloat(styles.padding) || 0;
            return { gridRect, cellSize: cellRect.width, gap, padding, total: cellRect.width + gap };
        }
        
        // Determine whether there is enough vertical room to show the mobile banner
        function canShowBanner() {
            try {
                const docStyles = getComputedStyle(document.documentElement);
                const bannerH = parseFloat(docStyles.getPropertyValue('--mobile-banner-height')) || 120;
                const gridMetrics = getGridMetrics();
                const gridH = gridMetrics.gridRect.height || 0;
                const hud = document.querySelector('.hud-row');
                const hudH = hud ? hud.getBoundingClientRect().height : 0;
                const logo = document.querySelector('.logo');
                const logoH = logo ? logo.getBoundingClientRect().height : 0;
                const dock = document.querySelector('.dock');
                const dockH = dock ? dock.getBoundingClientRect().height : 0;
                const topInset = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--safe-top') || 0) || 0;
                const paddingExtra = 40; // small breathing room
                const needed = bannerH + gridH + hudH + logoH + dockH + paddingExtra + topInset;
                return window.innerHeight >= needed;
            } catch (e) { return false; }
        }

        function checkAndToggleBanner(){
            const mobileBanner = document.getElementById('mobile-banner');
            if (!mobileBanner) return;
            if ((isGameActive || isTutorialActive) && canShowBanner()) {
                mobileBanner.style.display = 'flex';
            } else {
                mobileBanner.style.display = 'none';
            }
        }
        function indexToCell(r,c){ return gridEl.querySelectorAll('.cell')[r*GRID_SIZE + c]; }
        function highlightCells(r, startC, len){
            const cells = gridEl.querySelectorAll('.cell');
            for (let i=0;i<len;i++) cells[r*GRID_SIZE + (startC+i)].classList.add('highlight');
        }
        function highlightArea(r, c, h, w){
            const cells = gridEl.querySelectorAll('.cell');
            for (let i=0;i<h;i++){
                for (let j=0;j<w;j++){
                    cells[(r+i)*GRID_SIZE + (c+j)].classList.add('highlight');
                }
            }
        }
        function clearHighlightsReal(){ gridEl.querySelectorAll('.cell.highlight').forEach(el=>el.classList.remove('highlight')); }
        function backupState(){
            __tutorialBackup = {
                grid: gridState.map(row=>row.slice()),
                score,
                timeLeft
            };
        }
        function restoreState(){
            if (!__tutorialBackup) return;
            gridState = __tutorialBackup.grid.map(row=>row.slice());
            score = __tutorialBackup.score;
            timeLeft = __tutorialBackup.timeLeft;
            updateGridVisuals();
        }
        async function animateGhostPlacement(matrix, targetRow, targetCol, colorIdx){
            const rows = matrix.length; const cols = matrix[0].length;
            const { gridRect, cellSize, gap, padding, total } = getGridMetrics();
            const ghost = document.createElement('div');
            ghost.className = 'tutorial-ghost';
            ghost.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            ghost.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
            ghost.style.gap = `${gap}px`;
            ghost.style.width = `${cols*cellSize + (cols-1)*gap}px`;
            ghost.style.height = `${rows*cellSize + (rows-1)*gap}px`;
            for (let r=0;r<rows;r++){
                for (let c=0;c<cols;c++){
                    const d = document.createElement('div');
                    if (matrix[r][c]===1){
                        d.className = 'ghost-cell';
                        d.style.width = `${cellSize}px`;
                        d.style.height = `${cellSize}px`;
                    } else {
                        d.style.width = `${cellSize}px`;
                        d.style.height = `${cellSize}px`;
                        d.style.opacity = '0';
                    }
                    ghost.appendChild(d);
                }
            }
            const dockRect = dockEl.getBoundingClientRect();
            const startLeft = dockRect.left + (dockRect.width - (cols*cellSize + (cols-1)*gap)) / 2;
            const startTop  = dockRect.top + 6;
            ghost.style.left = `${startLeft}px`;
            ghost.style.top  = `${startTop}px`;
            ghost.style.opacity = '0.98';
            ghost.style.transform = 'scale(0.96)';
            document.body.appendChild(ghost);

            // pointer from dock to target (apply a downward offset so the large hand sits lower)
            let handOffsetY = 0;
            try {
                const hr = tutorialPointer.getBoundingClientRect();
                handOffsetY = Math.round((hr.height || 0) * 0.32);
            } catch(e) { handOffsetY = 0; }
            tutorialPointer.style.left = (dockRect.left + dockRect.width*0.65) + 'px';
            tutorialPointer.style.top  = (dockRect.top + 22 + handOffsetY) + 'px';

            await delay(600);
            const targetLeft = gridRect.left + padding + targetCol*total;
            const targetTop  = gridRect.top  + padding + targetRow*total;
            // add a little pop as it moves into position
            ghost.style.transform = 'scale(1.02)';
            ghost.style.left = `${targetLeft}px`;
            ghost.style.top  = `${targetTop}px`;
            tutorialPointer.style.left = (targetLeft + cols*cellSize - 8) + 'px';
            tutorialPointer.style.top  = (targetTop + rows*cellSize + 12 + handOffsetY) + 'px';
            await delay(1600);
            // settle
            ghost.style.transform = 'scale(1)';
            clearHighlightsReal();
            placeBlock(matrix, targetRow, targetCol, colorIdx);
            await delay(540);
            ghost.style.opacity = '0';
            await delay(360);
            ghost.remove();
        }

        function startTutorial() {
            // Ensure gameplay is disabled during tutorial
            isGameActive = false; isTutorialActive = true;
            // Toggle banner only if there's room
            try { checkAndToggleBanner(); } catch(e) {}

            tutorialOverlay.style.display = 'flex';
            // start light tutorial floats
            try { startTutorialFloats(); } catch(e){}
            tutorialStage = 0;
            tutorialCta.style.display = 'none';
            runTutorialSequence();
        }


        // No skip tutorial option per request

        function endTutorialAndStart(){
            tutorialOverlay.style.display = 'none';
            clearHighlightsReal();
            restoreState();
            isTutorialActive = false;
            // cleanup tutorial floats
            try {
                clearInterval(window.__tutFloatTimer);
                window.__tutActivePositions = [];
                const host = document.querySelector('.tutorial-floats');
                if (host) host.querySelectorAll('.float').forEach(el => el.remove());
            } catch(e) {}
            // Hide the mobile banner after the tutorial completes (keep DOM present but hidden)
            try { const mobileBanner = document.getElementById('mobile-banner'); if (mobileBanner) mobileBanner.style.display = 'none'; } catch(e) {}
            userInteractStart();
        }

        function tutorialNextStep(){
            // Final CTA pressed
            endTutorialAndStart();
        }

        function delay(ms){ return new Promise(r => setTimeout(r, ms)); }

        function rectRel(child, relativeTo){
            const cr = child.getBoundingClientRect();
            const rr = relativeTo.getBoundingClientRect();
            return { left: cr.left - rr.left, top: cr.top - rr.top, width: cr.width, height: cr.height };
        }

        async function runTutorialSequence(){
            backupState();
            // Position banner relative to grid; will tweak per step
            const { gridRect } = getGridMetrics();
            const bannerWidth = Math.min(gridRect.width * 0.86, gridRect.width);
            tutorialBanner.style.width = bannerWidth + 'px';
            tutorialBanner.style.left = (gridRect.left + (gridRect.width - bannerWidth)/2) + 'px';
            tutorialBanner.style.transform = 'translate(0, -50%)';
            // add entrance animation class
            tutorialBanner.classList.add('animate');

            // STEP 1: Place a block (no clear)
            // Banner slightly above center for placement clarity
            tutorialBanner.style.top = (gridRect.top + gridRect.height * 0.28) + 'px';
            tutorialPointer.classList.add('idle');
            for (let r=0;r<GRID_SIZE;r++) for (let c=0;c<GRID_SIZE;c++) gridState[r][c] = null;
            updateGridVisuals();
            tutorialBanner.textContent = 'Step 1 of 3  Drag a block to place it';
            const m1 = [[1,1],[1,1]]; // 2x2 square
            highlightArea(2,2,2,2);
            await animateGhostPlacement(m1, 2, 2, 2);
            await delay(1400);

            // STEP 2: Complete a row
            // Lower banner a bit to make room for the pointer and row action
            tutorialBanner.style.top = (gridRect.top + gridRect.height * 0.36) + 'px';
            tutorialBanner.textContent = 'Step 2 of 3  Complete a row to clear it';
            for (let r=0;r<GRID_SIZE;r++) for (let c=0;c<GRID_SIZE;c++) gridState[r][c] = null;
            const demoRow = 3; const startCol = 2; const pieceLen = 3; const colorIdx = 2;
            for (let c=0;c<GRID_SIZE;c++) if (c<startCol || c>startCol+pieceLen-1) gridState[demoRow][c] = colorIdx;
            updateGridVisuals();
            highlightCells(demoRow, startCol, pieceLen);
            await animateGhostPlacement([[1,1,1]], demoRow, startCol, colorIdx);
            // Reward popups
            const { gridRect: gr2 } = getGridMetrics();
            tPopScore.classList.remove('show'); tPopTime.classList.remove('show');
            tPopScore.style.left = (gr2.left + gr2.width/2) + 'px';
            tPopScore.style.top  = (gr2.top + gr2.height/2) + 'px';
            tPopTime.style.left  = (gr2.left + gr2.width/2 + 24) + 'px';
            tPopTime.style.top   = (gr2.top + gr2.height/2 + 28) + 'px';
            tPopScore.classList.add('show');
            await delay(260);
            tPopTime.classList.add('show');
            await delay(1500);

            // STEP 3: Complete a column
            // Raise banner higher for column action so it doesn't overlap the column
            tutorialBanner.style.top = (gridRect.top + gridRect.height * 0.22) + 'px';
            tutorialBanner.textContent = 'Step 3 of 3  Complete a column to clear it';
            for (let r=0;r<GRID_SIZE;r++) for (let c=0;c<GRID_SIZE;c++) gridState[r][c] = null;
            const demoCol = 4; const startRow = 2; const vLen = 3;
            for (let r=0;r<GRID_SIZE;r++) if (r<startRow || r>startRow+vLen-1) gridState[r][demoCol] = colorIdx;
            updateGridVisuals();
            highlightArea(startRow, demoCol, vLen, 1);
            await animateGhostPlacement([[1],[1],[1]], startRow, demoCol, colorIdx);
            // Reward popups again
            const { gridRect: gr3 } = getGridMetrics();
            tPopScore.classList.remove('show'); tPopTime.classList.remove('show');
            tPopScore.style.left = (gr3.left + gr3.width/2) + 'px';
            tPopScore.style.top  = (gr3.top + gr3.height/2) + 'px';
            tPopTime.style.left  = (gr3.left + gr3.width/2 + 24) + 'px';
            tPopTime.style.top   = (gr3.top + gr3.height/2 + 28) + 'px';
            tPopScore.classList.add('show');
            await delay(260);
            tPopTime.classList.add('show');

            await delay(2400);
            endTutorialAndStart();
        }

        // Preload assets, then start tutorial (logo pulses during wait)
        async function preloadSimple(paths, timeoutMs = 2800){
            const loadingOverlay = document.getElementById('loading-overlay');
            const jobs = paths.map(p => new Promise(res => { const img = new Image(); img.onload = img.onerror = () => res(); img.src = p; }));
            await Promise.race([Promise.all(jobs), new Promise(r => setTimeout(r, timeoutMs))]);
            await delay(150);
            if (loadingOverlay) loadingOverlay.style.display = 'none';
        }

        (async function startAfterPreload(){
            const assetsToPreload = [
                'images/imagSe.png','images/hand.png','images/Logo.png','images/HC-bg.png','images/Group 9.png','images/paypal.png','images/Logo2 - Small.png','images/Logo2.png','images/install-cta.png','images/bar.png','images/sun.png'
            ];
            try { await preloadSimple(assetsToPreload, 3200); } catch(e){}
            // ensure loading overlay remains visible for the remaining branding pause
            const loadingOverlay = document.getElementById('loading-overlay');
            try { if (loadingOverlay) { loadingOverlay.style.display = 'flex'; loadingOverlay.classList.add('prep'); } } catch(e){}
            // prepare tutorial assets (images/templates) while the logo pulses
            try { prepareTutorialAssets(assetsToPreload); } catch(e){}
            // brief extra pause to ensure layout paints
            await delay(200);
            // Start background floating money once the page is ready
            try { startBackgroundFloats(); } catch(e){}
            // Hold on the loading/logo pulse for 4 seconds so players perceive the brand
            await delay(4000);
            // remove the prep class so pulse returns to normal and hide overlay
            try { if (loadingOverlay) { loadingOverlay.classList.remove('prep'); loadingOverlay.style.display = 'none'; } } catch(e){}
            // Always show the tutorial on load per request
            startTutorial();
        })();

        // --- Background floating money spawner ---
        function startBackgroundFloats(){
            const host = document.querySelector('.bg-floats');
            if (!host) return;
            // Responsive density: adjust for mobile vs desktop
            const isMobile = window.matchMedia('(max-width:600px)').matches;
            if (!window.__bgActivePositions) {
                window.__bgActivePositions = [];
                const existing = host.querySelectorAll('.float');
                existing.forEach(el => {
                    const leftStr = (el.style.left || '').trim();
                    if (leftStr.endsWith('%')) {
                        const n = parseFloat(leftStr);
                        if (!Number.isNaN(n)) window.__bgActivePositions.push(n);
                    }
                });
            }

            const MIN_DIST = isMobile ? 6 : 6; // allow denser clusters on all screens
            const MAX_TRIES = 14;
            const pickLeft = () => {
                let best = null, bestGap = -1;
                for (let i = 0; i < MAX_TRIES; i++) {
                    const cand = 5 + Math.random() * 90;
                    let gap = Infinity;
                    for (const p of window.__bgActivePositions) gap = Math.min(gap, Math.abs(cand - p));
                    if (gap >= MIN_DIST) return cand;
                    if (gap > bestGap) { bestGap = gap; best = cand; }
                }
                return best ?? (5 + Math.random() * 90);
            };

            const spawnFloat = () => {
                const isCoin = Math.random() < 0.8; // favor coins for visual density
                const el = document.createElement('div');
                el.className = 'float ' + (isCoin ? 'coin' : 'dollar');
                if (!isCoin) el.textContent = '$';
                const left = pickLeft();
                el.style.left = left + '%';
                el.dataset.left = String(left);
                window.__bgActivePositions.push(left);

                if (isCoin) {
                    const base = isMobile ? 18 : 24;
                    const size = base + Math.random() * (isMobile ? 22 : 36);
                    el.style.width = size + 'px';
                    el.style.height = size + 'px';
                    el.style.opacity = isMobile ? 0.22 : 0.28;
                } else {
                    el.style.fontSize = (16 + Math.random() * 18) + 'px';
                    el.style.opacity = isMobile ? 0.18 : 0.22;
                }

                const dur = (isMobile ? 14 : 20) + Math.random() * (isMobile ? 8 : 14);
                el.style.animationDuration = dur + 's';
                el.style.animationDelay = (-Math.random() * dur) + 's';
                host.appendChild(el);

                // add occasional gentle sway to make motion feel organic
                if (Math.random() < 0.85) el.classList.add('sway');

                setTimeout(() => {
                    const val = parseFloat(el.dataset.left || 'NaN');
                    if (!Number.isNaN(val)) {
                        const idx = window.__bgActivePositions.indexOf(val);
                        if (idx >= 0) window.__bgActivePositions.splice(idx, 1);
                    }
                    try{ el.remove(); }catch(e){}
                }, (dur + 2) * 1000);
            };

            const seedCount = isMobile ? 14 : 28; // start with more floats
            for (let i = 0; i < seedCount; i++) spawnFloat();

            clearInterval(window.__bgFloatTimer);
            window.__bgFloatTimer = setInterval(() => {
                if (document.hidden) return;
                // sometimes spawn a small burst for livelier background
                const burst = Math.random() < 0.25 ? (1 + Math.floor(Math.random() * 3)) : 1;
                for (let b = 0; b < burst; b++) spawnFloat();
            }, isMobile ? 900 : 700);
        }

        // Prepare tutorial assets while loading so the demo runs without hiccups
        function prepareTutorialAssets(paths){
            try {
                // ensure common images are cached in memory
                window.__tutImages = window.__tutImages || {};
                const toLoad = ['images/imagSe.png','images/hand.png','images/Logo.png','images/Logo2 - Small.png'];
                toLoad.forEach(p => {
                    if (window.__tutImages[p]) return;
                    const img = new Image();
                    img.src = p;
                    window.__tutImages[p] = img;
                });

                // create an offscreen container with a hidden ghost template so layout is prepared
                if (!document.getElementById('__tut_offscreen')){
                    const off = document.createElement('div');
                    off.id = '__tut_offscreen';
                    off.style.position = 'absolute';
                    off.style.left = '-9999px';
                    off.style.top = '-9999px';
                    off.style.width = '1px';
                    off.style.height = '1px';
                    off.style.overflow = 'hidden';
                    // small ghost template (1x1) to warm CSS rules
                    const tghost = document.createElement('div');
                    tghost.className = 'tutorial-ghost';
                    tghost.style.opacity = '0';
                    tghost.setAttribute('aria-hidden','true');
                    off.appendChild(tghost);
                    document.body.appendChild(off);
                }
            } catch(e) { /* non-fatal */ }
        }

        // --- Tutorial overlay floating money spawner (more spaced, lighter) ---
        function startTutorialFloats(){
            const host = document.querySelector('.tutorial-floats');
            if (!host) return;
            const isMobile = window.matchMedia('(max-width:600px)').matches;
            if (!window.__tutActivePositions) window.__tutActivePositions = [];
            const MIN_DIST = isMobile ? 12 : 10; // percent
            const MAX_TRIES = 12;
            const pickLeft = () => {
                let best = null, bestGap = -1;
                for (let i=0;i<MAX_TRIES;i++){
                    const cand = 6 + Math.random()*88;
                    let gap = Infinity;
                    for (const p of window.__tutActivePositions) gap = Math.min(gap, Math.abs(cand - p));
                    if (gap >= MIN_DIST) return cand;
                    if (gap > bestGap) { bestGap = gap; best = cand; }
                }
                return best ?? (6 + Math.random()*88);
            };
            const spawn = () => {
                const isCoin = Math.random() < 0.72;
                const el = document.createElement(isCoin ? 'img' : 'div');
                el.className = 'float ' + (isCoin ? 'coin' : 'dollar');
                if (isCoin) { el.src = 'images/imagSe.png'; el.alt = ''; }
                else { el.textContent = '$'; }
                const left = pickLeft();
                el.style.left = left + '%';
                el.dataset.left = String(left);
                window.__tutActivePositions.push(left);
                if (isCoin){ const size = (isMobile?18:22) + Math.random()*(isMobile?14:22); el.style.width = size+'px'; el.style.height = size+'px'; }
                else { el.style.fontSize = (isMobile?18:20) + Math.random()*(isMobile?12:18) + 'px'; el.style.opacity = isMobile?0.22:0.28; }
                const dur = (isMobile?12:16) + Math.random()*(isMobile?8:12);
                el.style.animationDuration = dur + 's'; el.style.animationDelay = (-Math.random()*dur)+'s';
                host.appendChild(el);
                if (Math.random() < 0.75) el.classList.add('sway');
                setTimeout(()=>{
                    const val = parseFloat(el.dataset.left || 'NaN');
                    if (!Number.isNaN(val)) {
                        const idx = window.__tutActivePositions.indexOf(val);
                        if (idx>=0) window.__tutActivePositions.splice(idx, 1);
                    }
                    try{ el.remove(); }catch(e){}
                }, (dur+1.5)*1000);
            };
            const seed = isMobile?6:8;
            for (let i=0;i<seed;i++) spawn();
            clearInterval(window.__tutFloatTimer);
            window.__tutFloatTimer = setInterval(()=>{ if (document.hidden) return; spawn(); }, isMobile?1400:1200);
        }
    </script>

    <script>
        // Runtime adjustments for very short viewports (e.g., iPhone SE) to avoid cropping
        (function(){
            const shortCls = 'short-screen';
            const veryShortCls = 'very-short-screen';
            function applyClasses(){
                const h = window.innerHeight || document.documentElement.clientHeight;
                document.documentElement.classList.remove(shortCls, veryShortCls);
                if (h <= 568) document.documentElement.classList.add(veryShortCls);
                else if (h <= 640) document.documentElement.classList.add(shortCls);
            }
            window.addEventListener('resize', applyClasses);
            window.addEventListener('orientationchange', applyClasses);
            // apply on load
            applyClasses();
        })();
    </script>

    <div class="hey-banner" onclick="installApp()">
        <div class="hey-logo-area">
            <div class="hey-icon">
                <img src="images/Logo2.png" alt="HeyCash Logo">
            </div>
            <div class="hey-text">
                <div class="hey-title">HeyCash</div>
                <div class="hey-subtitle">Get Rewards</div>
            </div>
        </div>
        
        <div class="card-stack">
            <div class="c-card one"></div>
            <div class="c-card two"></div>
            <div class="c-card three"></div>
        </div>
        
        <button class="hey-btn">Install</button>
    </div>

    <button class="desktop-install-cta" onclick="installApp()" aria-label="Install HeyCash">INSTALL</button>

</body>
</html>

